// Autogenerated using stratification.
requires "x86-configuration.k"

module MOVAPS-XMM-XMM
  imports X86-CONFIGURATION

  rule <k>
    execinstr (movaps R1:Xmm, R2:Xmm,  .Typedoperands) => .
  ...</k>
    <regstate> 
RSMap:Map => updateMap(RSMap,

convToRegKeys(R2) |-> (concatenateMInt(extractMInt(getParentValue(R2, RSMap), 0, 128), extractMInt(getParentValue(R1, RSMap), 128, 256)) )



)
    </regstate>
endmodule

module MOVAPS-XMM-XMM-SEMANTICS
  imports MOVAPS-XMM-XMM
endmodule


/*circuit:callq .move_128_032_xmm2_xmm4_xmm5_xmm6_xmm7  #  1     0    5      OPC=callq_label
circuit:callq .move_032_128_xmm4_xmm5_xmm6_xmm7_xmm1  #  2     0x5  5      OPC=callq_label


maybe read:{ %xmm2 }
must read:{ %xmm2 }
maybe write:{ %xmm1 }
must write:{ %xmm1 }
maybe undef:{ }
must undef:{ }
required flags:{ sse }


WARNING: No live out values provided, assuming { }

WARNING: No def in values provided; assuming { %mxcsr::rc[0] }

Target



movaps %xmm2, %xmm1



  maybe read:      { %xmm2 }

  must read:       { %xmm2 }

  maybe write:     { %xmm1 }

  must write:      { %xmm1 }

  maybe undef:     { }

  must undef:      { }

  required flags:  { sse }



-------------------------------------

Getting base circuit for callq .move_128_032_xmm2_xmm4_xmm5_xmm6_xmm7



Final state:

%rax/%rax: %rax_movaps_xmm_xmm

%rdx/%rdx: %rdx_movaps_xmm_xmm



%xmm0: %ymm0_movaps_xmm_xmm[127:0]

%xmm1: %ymm1_movaps_xmm_xmm[127:0]



-------------------------------------

-------------------------------------

Getting base circuit for callq .move_032_128_xmm4_xmm5_xmm6_xmm7_xmm1



Final state:

%rax/%rax: %rax_movaps_xmm_xmm

%rdx/%rdx: %rdx_movaps_xmm_xmm



%xmm0: %ymm0_movaps_xmm_xmm[127:0]

%xmm1: (%ymm1_movaps_xmm_xmm[255:128] ∘ ((%ymm7_movaps_xmm_xmm[255:128] ∘ (0x0₉₆ ∘ %ymm2_movaps_xmm_xmm[127:0][127:96]))[127:0][31:0] ∘ (%ymm6_movaps_xmm_xmm[255:128] ∘ (0x0₉₆ ∘ %ymm2_movaps_xmm_xmm[127:0][95:64]))[127:0][31:0] ∘ (%ymm5_movaps_xmm_xmm[255:128] ∘ (0x0₉₆ ∘ %ymm2_movaps_xmm_xmm[127:0][63:32]))[127:0][31:0] ∘ (%ymm4_movaps_xmm_xmm[255:128] ∘ (0x0₉₆ ∘ %ymm2_movaps_xmm_xmm[127:0][31:0]))[127:0][31:0]))[127:0]



-------------------------------------

=====================================

Computing circuit for movaps %xmm2, %xmm1



.target:

callq .move_128_032_xmm2_xmm4_xmm5_xmm6_xmm7

callq .move_032_128_xmm4_xmm5_xmm6_xmm7_xmm1

retq 



Initial state:

%xmm1: %ymm1[127:0]



State for specgen instruction: movaps %xmm2, %xmm1:

%xmm1: (%ymm1_movaps_xmm_xmm[255:128] ∘ ((%ymm7_movaps_xmm_xmm[255:128] ∘ (0x0₉₆ ∘ %ymm2_movaps_xmm_xmm[127:0][127:96]))[127:0][31:0] ∘ (%ymm6_movaps_xmm_xmm[255:128] ∘ (0x0₉₆ ∘ %ymm2_movaps_xmm_xmm[127:0][95:64]))[127:0][31:0] ∘ (%ymm5_movaps_xmm_xmm[255:128] ∘ (0x0₉₆ ∘ %ymm2_movaps_xmm_xmm[127:0][63:32]))[127:0][31:0] ∘ (%ymm4_movaps_xmm_xmm[255:128] ∘ (0x0₉₆ ∘ %ymm2_movaps_xmm_xmm[127:0][31:0]))[127:0][31:0]))[127:0]



Final state

%xmm1: (%ymm1[255:128] ∘ %ymm2[127:0])[127:0]



=====================================

Circuits:



%ymm1  : %ymm1[255:128] ∘ %ymm2[127:0]



sigfpe  : sigfpe

sigbus  : sigbus

sigsegv : sigsegv

*/