// Autogenerated using stratification.
requires "x86-configuration.k"

module NOTQ-R64
  imports X86-CONFIGURATION

  rule <k>
    execinstr (notq R1:R64,  .Typedoperands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
convToRegKeys(R1) |-> (xorMInt(mi(64, 18446744073709551615), getParentValue(R1, RSMap)) )


)

    </regstate>
endmodule

module NOTQ-R64-SEMANTICS
  imports NOTQ-R64
endmodule
/*
TargetInstr:
notq %rbx
RWSet:
maybe read:{ %rbx }
must read:{ %rbx }
maybe write:{ %rbx }
must write:{ %rbx }
maybe undef:{ }
must undef:{ }
required flags:{ }

Circuit:
circuit:movq $0xfffffffffffffffe, %rdx  #  1     0    10     OPC=movq_r64_imm64
circuit:incb %dl                        #  2     0xa  2      OPC=incb_r8
circuit:xorq %rdx, %rbx                 #  3     0xc  3      OPC=xorq_r64_r64
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

notq %rbx

  maybe read:      { %rbx }
  must read:       { %rbx }
  maybe write:     { %rbx }
  must write:      { %rbx }
  maybe undef:     { }
  must undef:      { }
  required flags:  { }

-------------------------------------
Getting base circuit for movq $0xfffffffffffffffe, %rdx

Final state:
%rdx/%rdx: 0xfffffffffffffffe₆₄

-------------------------------------
-------------------------------------
Getting base circuit for xorq %rax, %rax

Final state:
%rax/%rax: %rax_incb_r8 ⊕ %rax_incb_r8

%cf: false
%pf: !((%rax_incb_r8 ⊕ %rax_incb_r8)[7:0][0:0] = 0x1₁ ⊕ (%rax_incb_r8 ⊕ %rax_incb_r8)[7:0][1:1] = 0x1₁ ⊕ (%rax_incb_r8 ⊕ %rax_incb_r8)[7:0][2:2] = 0x1₁ ⊕ (%rax_incb_r8 ⊕ %rax_incb_r8)[7:0][3:3] = 0x1₁ ⊕ (%rax_incb_r8 ⊕ %rax_incb_r8)[7:0][4:4] = 0x1₁ ⊕ (%rax_incb_r8 ⊕ %rax_incb_r8)[7:0][5:5] = 0x1₁ ⊕ (%rax_incb_r8 ⊕ %rax_incb_r8)[7:0][6:6] = 0x1₁ ⊕ (%rax_incb_r8 ⊕ %rax_incb_r8)[7:0][7:7] = 0x1₁)
%zf: (%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄
%sf: (%rax_incb_r8 ⊕ %rax_incb_r8)[63:63] = 0x1₁
%of: false

-------------------------------------
-------------------------------------
Getting base circuit for xorq %rax, %rax

Final state:
%rax/%rax: %rax_clc ⊕ %rax_clc

%cf: false
%pf: !((%rax_clc ⊕ %rax_clc)[7:0][0:0] = 0x1₁ ⊕ (%rax_clc ⊕ %rax_clc)[7:0][1:1] = 0x1₁ ⊕ (%rax_clc ⊕ %rax_clc)[7:0][2:2] = 0x1₁ ⊕ (%rax_clc ⊕ %rax_clc)[7:0][3:3] = 0x1₁ ⊕ (%rax_clc ⊕ %rax_clc)[7:0][4:4] = 0x1₁ ⊕ (%rax_clc ⊕ %rax_clc)[7:0][5:5] = 0x1₁ ⊕ (%rax_clc ⊕ %rax_clc)[7:0][6:6] = 0x1₁ ⊕ (%rax_clc ⊕ %rax_clc)[7:0][7:7] = 0x1₁)
%zf: (%rax_clc ⊕ %rax_clc) = 0x0₆₄
%sf: (%rax_clc ⊕ %rax_clc)[63:63] = 0x1₁
%of: false

-------------------------------------
-------------------------------------
Getting base circuit for adcb %al, %al

Final state:
%rax/%al: (%rax_clc ⊕ %rax_clc)[63:8] ∘ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0]

%cf: ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[8:8] = 0x1₁
%pf: !(((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:0][0:0] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:0][1:1] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:0][2:2] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:0][3:3] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:0][4:4] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:0][5:5] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:0][6:6] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:0][7:7] = 0x1₁)
%af: (0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0][3:0] + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0][3:0])[4:4] = 0x1₁
%zf: ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0] = 0x0₈
%sf: ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:0][7:7] = 0x1₁
%of: ((%rax_clc ⊕ %rax_clc)[7:0][7:7] = 0x1₁ ↔ (%rax_clc ⊕ %rax_clc)[7:0][7:7] = 0x1₁) ∧ !((%rax_clc ⊕ %rax_clc)[7:0][7:7] = 0x1₁ ↔ ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[7:7] = 0x1₁)

-------------------------------------
=====================================
Computing circuit for clc 

.target:
xorq %rax, %rax
adcb %al, %al
retq 

Initial state:
%cf: false

State for specgen instruction: clc :
%cf: ((false ? 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0] + 0x1₉ : 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0]) + 0x0₁ ∘ (%rax_clc ⊕ %rax_clc)[7:0])[8:8] = 0x1₁

Final state
%cf: false

=====================================
-------------------------------------
Getting base circuit for callq .read_zf_into_rcx

Final state:
%rax/%rax: %rax_incb_r8 ⊕ %rax_incb_r8
%rdx/%rdx: %rdx_incb_r8

%xmm0: %ymm0_incb_r8[127:0]
%xmm1: %ymm1_incb_r8[127:0]

-------------------------------------
-------------------------------------
Getting base circuit for adcb %cl, %bl

Final state:
%rbx/%bl: %rbx_incb_r8[63:8] ∘ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0]

%cf: ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[8:8] = 0x1₁
%pf: !(((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][0:0] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][1:1] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][2:2] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][3:3] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][4:4] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][5:5] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][6:6] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][7:7] = 0x1₁)
%af: (0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0][3:0] + 0x0₁ ∘ %rbx_incb_r8[7:0][3:0])[4:4] = 0x1₁
%zf: ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0] = 0x0₈
%sf: ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:7] = 0x1₁
%of: ((0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0][7:7] = 0x1₁ ↔ %rbx_incb_r8[7:0][7:7] = 0x1₁) ∧ !((0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0][7:7] = 0x1₁ ↔ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:7] = 0x1₁)

-------------------------------------
=====================================
Computing circuit for incb %dl

.target:
xorq %rax, %rax
clc 
callq .read_zf_into_rcx
adcb %cl, %bl
retq 

Initial state:
%rdx/%dl: 0xfffffffffffffffe₆₄

%pf: %pf_notq_r64
%af: %af_notq_r64
%zf: %zf_notq_r64
%sf: %sf_notq_r64
%of: %of_notq_r64

State for specgen instruction: incb %bl:
%rbx/%bl: %rbx_incb_r8[63:8] ∘ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0]

%pf: !(((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][0:0] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][1:1] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][2:2] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][3:3] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][4:4] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][5:5] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][6:6] = 0x1₁ ⊕ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:0][7:7] = 0x1₁)
%af: (0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0][3:0] + 0x0₁ ∘ %rbx_incb_r8[7:0][3:0])[4:4] = 0x1₁
%zf: ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0] = 0x0₈
%sf: ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0][7:7] = 0x1₁
%of: ((0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0][7:7] = 0x1₁ ↔ %rbx_incb_r8[7:0][7:7] = 0x1₁) ∧ !((0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0][7:7] = 0x1₁ ↔ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:7] = 0x1₁)

Register        -> %bl
  translates to => %dl
Value is               -> (%rbx_incb_r8[63:8] ∘ ((false ? 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0] + 0x1₉ : 0x0₁ ∘ (0x0₆₃ ∘ ((%rax_incb_r8 ⊕ %rax_incb_r8) = 0x0₆₄ ? 0x1₁ : 0x0₁))[7:0]) + 0x0₁ ∘ %rbx_incb_r8[7:0])[7:0])[7:0]
  after renaming it is => 0xff₈

Final state
%rdx/%dl: 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈

%pf: true
%af: false
%zf: false
%sf: true
%of: false

=====================================
-------------------------------------
Getting base circuit for xorq %rdx, %rbx

Final state:
%rbx/%rbx: %rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈

%cf: false
%pf: !((%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[7:0][0:0] = 0x1₁ ⊕ (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[7:0][1:1] = 0x1₁ ⊕ (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[7:0][2:2] = 0x1₁ ⊕ (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[7:0][3:3] = 0x1₁ ⊕ (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[7:0][4:4] = 0x1₁ ⊕ (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[7:0][5:5] = 0x1₁ ⊕ (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[7:0][6:6] = 0x1₁ ⊕ (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[7:0][7:7] = 0x1₁)
%zf: (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈) = 0x0₆₄
%sf: (%rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈)[63:63] = 0x1₁
%of: false

-------------------------------------
=====================================
Computing circuit for notq %rbx

.target:
movq $0xfffffffffffffffe, %rdx
incb %dl
xorq %rdx, %rbx
retq 

Initial state:
%rbx/%rbx: %rbx

State for specgen instruction: notq %rbx:
%rbx/%rbx: %rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈

Register        -> %rbx
  translates to => %rbx
Value is               -> %rbx_notq_r64 ⊕ 0xfffffffffffffffe₆₄[63:8] ∘ 0xff₈
  after renaming it is => %rbx ⊕ 0xffffffffffffffff₆₄

Final state
%rbx/%rbx: %rbx ⊕ 0xffffffffffffffff₆₄

=====================================
Circuits:

%rbx   : %rbx ⊕ 0xffffffffffffffff₆₄

sigfpe  : sigfpe
sigbus  : sigbus
sigsegv : sigsegv

*/