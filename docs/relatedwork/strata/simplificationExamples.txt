// derivedInstructions/x86-vmovdqu_ymm_ymm.k 

rule <k>
    execinstr (vmovdqu R1:Ymm, R2:Ymm,  .Typedoperands) => .
  ...</k>
    <regstate> ...
convToRegKeys(R1) |-> (MI663 => MI663)

convToRegKeys(R2) |-> ( _ => concatenateMInt(Float2MInt(maxFloat(MInt2Float(extractMInt(concatenateMInt(extractMInt(MI663, 0, 32), concatenateMInt(extractMInt(MI663, 32, 64), concatenateMInt(extractMInt(MI663, 64, 96), concatenateMInt(extractMInt(MI663, 96, 128), concatenateMInt(extractMInt(MI663, 128, 160), concatenateMInt(extractMInt(MI663, 160, 192), concatenateMInt(extractMInt(MI663, 192, 224), extractMInt(MI663, 224, 256)))))))), 0, 64), 53, 11), MInt2Float(extractMInt(MI663, 0, 64), 53, 11)), 64), concatenateMInt(Float2MInt(maxFloat(MInt2Float(extractMInt(concatenateMInt(extractMInt(MI663, 0, 32), concatenateMInt(extractMInt(MI663, 32, 64), concatenateMInt(extractMInt(MI663, 64, 96), concatenateMInt(extractMInt(MI663, 96, 128), concatenateMInt(extractMInt(MI663, 128, 160), concatenateMInt(extractMInt(MI663, 160, 192), concatenateMInt(extractMInt(MI663, 192, 224), extractMInt(MI663, 224, 256)))))))), 64, 128), 53, 11), MInt2Float(extractMInt(MI663, 64, 128), 53, 11)), 64), concatenateMInt(Float2MInt(maxFloat(MInt2Float(extractMInt(concatenateMInt(extractMInt(MI663, 0, 32), concatenateMInt(extractMInt(MI663, 32, 64), concatenateMInt(extractMInt(MI663, 64, 96), concatenateMInt(extractMInt(MI663, 96, 128), concatenateMInt(extractMInt(MI663, 128, 160), concatenateMInt(extractMInt(MI663, 160, 192), concatenateMInt(extractMInt(MI663, 192, 224), extractMInt(MI663, 224, 256)))))))), 128, 192), 53, 11), MInt2Float(extractMInt(MI663, 128, 192), 53, 11)), 64), Float2MInt(maxFloat(MInt2Float(extractMInt(concatenateMInt(extractMInt(MI663, 0, 32), concatenateMInt(extractMInt(MI663, 32, 64), concatenateMInt(extractMInt(MI663, 64, 96), concatenateMInt(extractMInt(MI663, 96, 128), concatenateMInt(extractMInt(MI663, 128, 160), concatenateMInt(extractMInt(MI663, 160, 192), concatenateMInt(extractMInt(MI663, 192, 224), extractMInt(MI663, 224, 256)))))))), 192, 256), 53, 11), MInt2Float(extractMInt(MI663, 192, 256), 53, 11)), 64)))) )


    ...</regstate>


    to 

  rule <k>
    execinstr (vmovdqu R1:Ymm, R2:Ymm,  .Typedoperands) => .
  ...</k>
    <regstate> ...
convToRegKeys(R1) |-> (MI676 => MI676)

convToRegKeys(R2) |-> ( _ => MI676 )


    ...</regstate>
endmodule


Example 2
===========

// Autogenerated using stratification.
requires "x86-configuration.k"

module XCHGQ-R64-R64
  imports X86-CONFIGURATION

  rule <k>
    execinstr (xchgq R1:R64, R2:R64,  .Typedoperands) => .
  ...</k>
    <regstate> ...
convToRegKeys(R2) |-> ( MI437 => MI438 )

convToRegKeys(R1) |-> ( MI438 => concatenateMInt(extractMInt(orMInt(andMInt(mi(64, uvalueMInt(extractMInt(MI437, 0, 32))), mi(64, -65536)), mi(64, uvalueMInt(extractMInt(extractMInt(mi(64, uvalueMInt(concatenateMInt(extractMInt(mi(64, uvalueMInt(extractMInt(MI437, 0, 32))), 48, 64), extractMInt(mi(64, uvalueMInt(extractMInt(MI437, 32, 64))), 48, 64)))), 32, 64), 0, 16)))), 32, 64), extractMInt(orMInt(andMInt(mi(64, uvalueMInt(extractMInt(MI437, 32, 64))), mi(64, -65536)), mi(64, uvalueMInt(extractMInt(extractMInt(mi(64, uvalueMInt(concatenateMInt(extractMInt(mi(64, uvalueMInt(extractMInt(MI437, 0, 32))), 48, 64), extractMInt(mi(64, uvalueMInt(extractMInt(MI437, 32, 64))), 48, 64)))), 32, 64), 16, 32)))), 32, 64)) )


    ...</regstate>
endmodule

module XCHGQ-R64-R64-SEMANTICS
  imports XCHGQ-R64-R64
endmodule

to 

// Autogenerated using stratification.
requires "x86-configuration.k"

module XCHGQ-R64-R64
  imports X86-CONFIGURATION

  rule <k>
    execinstr (xchgq R1:R64, R2:R64,  .Typedoperands) => .
  ...</k>
    <regstate> ...
convToRegKeys(R2) |-> ( MI452 => MI451 )

convToRegKeys(R1) |-> ( MI451 => MI452 )


    ...</regstate>
endmodule

module XCHGQ-R64-R64-SEMANTICS
  imports XCHGQ-R64-R64
endmodule

due to lemma
 rule extractMInt(concatenateMInt(MI1, MI2), S, E) => MI2
    requires S ==Int bitwidthMInt(MI1) andBool E ==Int bitwidthMInt(MI1) +Int bitwidthMInt(MI2)
  rule extractMInt(concatenateMInt(MI1, MI2), S, E) => MI1
    requires S ==Int 0 andBool E ==Int bitwidthMInt(MI1)

  and change of plugInMask defintion


Example
====

// Autogenerated using stratification.
requires "x86-configuration.k"

module MOVAPS-XMM-XMM
  imports X86-CONFIGURATION

  rule <k>
    execinstr (movaps R1:Xmm, R2:Xmm,  .Typedoperands) => .
  ...</k>
    <regstate> ...
convToRegKeys(R1) |-> (MI439 => MI439)

convToRegKeys(R2) |-> ( MI438 => orMInt(andMInt(MI438, mi(256, -340282366920938463463374607431768211456)), mi(256, uvalueMInt(concatenateMInt(concatenateMInt(extractMInt(extractMInt(mi(256, uvalueMInt(mi(128, uvalueMInt(extractMInt(extractMInt(MI439, 128, 256), 0, 32))))), 128, 256), 96, 128), extractMInt(extractMInt(mi(256, uvalueMInt(mi(128, uvalueMInt(extractMInt(extractMInt(MI439, 128, 256), 32, 64))))), 128, 256), 96, 128)), concatenateMInt(extractMInt(extractMInt(mi(256, uvalueMInt(mi(128, uvalueMInt(extractMInt(extractMInt(MI439, 128, 256), 64, 96))))), 128, 256), 96, 128), extractMInt(extractMInt(mi(256, uvalueMInt(mi(128, uvalueMInt(extractMInt(extractMInt(MI439, 128, 256), 96, 128))))), 128, 256), 96, 128)))))) )


    ...</regstate>
endmodule

module MOVAPS-XMM-XMM-SEMANTICS
  imports MOVAPS-XMM-XMM
endmodule

to 

// Autogenerated using stratification.
requires "x86-configuration.k"

module MOVAPS-XMM-XMM
  imports X86-CONFIGURATION

  rule <k>
    execinstr (movaps R1:Xmm, R2:Xmm,  .Typedoperands) => .
  ...</k>
    <regstate> 
RSMap:Map => updateMap(RSMap,

convToRegKeys(R2) |-> (concatenateMInt(extractMInt(getRegisterValue(R2, RSMap), 0, 128), extractMInt(getRegisterValue(R1, RSMap), 128, 256)) )



)
    </regstate>
endmodule

module MOVAPS-XMM-XMM-SEMANTICS
  imports MOVAPS-XMM-XMM
endmodule


by fixing the rule for splitXmmToRegsIn32 (avoid zeroExtend)
  and using verification lemma
   rule concatenateMInt(extractMInt(MI, S1, E1), extractMInt(MI, S2, E2)) => extractMInt(MI, S1, E2) 
    requires E1 ==Int S2
  rule extractMInt(MI, S, E) => MI
    requires (bitwidthMInt(MI) ==Int E) andBool (S ==Int 0)
  rule extractMInt(concatenateMInt(MI1, MI2), S, E) => MI2
    requires S ==Int bitwidthMInt(MI1) andBool E ==Int bitwidthMInt(MI1) +Int bitwidthMInt(MI2)
  rule extractMInt(concatenateMInt(MI1, MI2), S, E) => MI1
    requires S ==Int 0 andBool E ==Int bitwidthMInt(MI1)

  rule extractMInt(concatenateMInt(MI1, MI2), S, E) => mi(E -Int S, 0) 
    requires zeroMInt(MI1) andBool E <=Int bitwidthMInt(MI1)
  rule extractMInt(concatenateMInt(MI1, MI2), S, E) => mi(E -Int S, 0) 
    requires zeroMInt(MI2) andBool S >=Int bitwidthMInt(MI1)



  Example
  =======
    rule <k>
    execinstr (setpe R1:R8,  .Typedoperands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
convToRegKeys(R1) |-> (concatenateMInt(extractMInt(getParentValue(R1, RSMap), 0, 56), extractMInt(mi(64, countOnes(concatenateMInt(mi(63, 0), getFlag("PF", RSMap)), 0)), 56, 64)) )


)

    </regstate>

    module SETPE-R8
  imports X86-CONFIGURATION

  rule <k>
    execinstr (setpe R1:R8,  .Typedoperands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
convToRegKeys(R1) |-> (concatenateMInt(extractMInt(getParentValue(R1, RSMap), 0, 56), concatenateMInt(mi(7, 0), getFlag("PF", RSMap))) )


)

    </regstate>
endmodule


