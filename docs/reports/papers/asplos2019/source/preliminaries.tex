\section{Preliminaries} \label{sec:Prilim}
In this section we will mention about two projects used extensively in our work. The first one is \K{}, , a semantics engineering tool in
which we chose to formalize our semantics. and the other is \Strata which we used to
obtain the semantics of individual X86-64 instructions.    

\subsection{Project Strata}

In order to get semantics of individual instructions, we build on top of project
\Strata~\cite{Heule2016a} which automatically synthesized formal semantics  of
the input/output behavior for $1796$ Haswell ISA X86-64 instructions. The key to
their results is stratified synthesis, where they use a set of instructions
whose semantics are known to synthesize the semantics of additional instructions
whose semantics are unknown. 
In a nutshell the approach is as follows. The approach needs as input  a small set of x86-64 instructions, the base set {\tt B}, whose semantics is already known. They execute
an instruction {\tt I} for which the formal semantics is not known yet on a set of test inputs {\tt TS} to obtain an initial description of its behavior. Then they search for a program {\tt p}, thats agrees with {\tt I} on T,  where {\tt p} only uses instructions drawn from the {\tt B}. This search will henceforth be referred as \initS{}. 



After that they perform multiple searches to get a set of programs {\tt P} all agreeing with {\tt I} on {\tt TS} and uses only the instructions from {\tt B}. These subseqent searches will henceforth be referred as \secS{}. Given two programs p, p$\prime$ $\in$ {\tt P}, they test whether $p\equiv_\text{Z3}p\prime$ using an SMT solver and the formulas from the base set. If the two programs are semantically distinct (meaning
the agreement on {\tt T} is coincidental), they know that one or both programs are not a correct description of {\tt I}. They use the model produced by the SMT solver to obtain an input {\tt t} that distinguishes $p$ and $p\prime$, add $t$ to the set of tests {\tt T}, and start over. This process is  repeated until they having enough programs according to a threshold. Once done, one {\tt p} $\in$ {\tt P} is chosen, according to some heuristics, and returned as the semantics of {\tt I}. Also {\tt p} is added to the base set {\tt B}.  This  enables stratified synthesis  as the vocabulary for expressing the semantics of more complex instructions expands.


Using this technique, they first came up with the semantics of $692$ register and
\revisit{$\sim120$} immediate instructions. The rest $\sim984$ are the immediate
and memory variants obtained by generalization of $692$ register instructions.     

\Strata uses \Stoke~\cite{Stoke2013} for the stochastic search step. \Stoke contains manually written formulas for a subset of the x86-64 instruction set, which \Strata uses to compare against the ones learned by stratification by asking an SMT solver if the formulas are equivalent.

\cmt{ 
    Using this combination of stochastic search + pruning
    using testing (we referred as {\tt initial search}) and subsequent refining of the
    search results using equivalence checking ({\tt henceforth referred as \secS{}
    }), }


\cmt{
    After having that {\tt initial search},
    they keep on searching  additional programs, called {\tt secondary
        searches}, each agreeing with {\tt I} on {\tt T} and using the instructions from {\tt B}, in a hope of
    getting  one which would prove non-equivalent to existing ones and
    thereby gaining more confidence on the searched programs. 
    
    In the process the initial set of test inputs got augmented by counter examples 
    
    and probably an
    augmented test-suite (as {\tt TS} might get augmented with a
    counter example from equivalence checker in the event of
    non-equivalence). 
}


\subsection{K Framework}
