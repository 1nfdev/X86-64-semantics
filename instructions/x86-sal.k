// Autogenerated from templates.
requires "x86-configuration.k"
requires "x86-flag-checks-syntax.k"

/*@ This file defines the semantics of following 51 base instructions.
  - salq_r64_cl
*/

module SAL-R64-CL
  imports X86-CONFIGURATION
  imports X86-FLAG-CHECKS-SYNTAX

  rule <k> 
    execinstr(salq  (%cl,  (R:R64, .Typedoperands)) ) =>
      execinstr(salq  (R,  (getRegisterValue(R, RSMap), shiftCountMask(getRegisterValue(%cl, RSMap), 64), .Typedoperands)) )
  ...</k>
    <regstate> RSMap </regstate>

  rule <k>
  execinstr(salq  (R,  (MIsrc:MInt, MIcount:MInt, .Typedoperands)) ) => 
    setFlag(
      (#ifMInt zeroMInt(MIcount)
      #then
        getFlag("OF", RSMap)
      #else
        #ifMInt eqMInt(MIcount, mi(bitwidthMInt(MIcount),1))
        #then
          xorMInt(getSignBit(MIsrc), getSignBit(shlMInt(MIsrc, 1)))
        #else
          undef
        #fi 
      #fi):>MInt  
        , 
        "OF") ~> 

    updateZeroFlag(
      #ifMInt zeroMInt(MIcount)
      #then
        #ifMInt eqMInt( getFlag("ZF", RSMap), mi(1, 1)) 
        #then
          mi(64, 0)
        #else
          mi(64, 1)
        #fi  
      #else
        #ifMInt  ultMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))
        #then
          shlMInt(MIsrc, uvalueMInt(MIcount))
        #else 
          salOverflow(MIsrc)
        #fi 
      #fi  
        ) ~> 

    updateSignFlag(
      #ifMInt zeroMInt(MIcount)
      #then
        #ifMInt eqMInt( getFlag("SF", RSMap), mi(1, 1)) 
        #then
          mi(64, -9223372036854775808)
        #else
          mi(64, 0)
        #fi  
      #else
        #ifMInt  ultMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))
        #then
          shlMInt(MIsrc, uvalueMInt(MIcount))
        #else 
          salOverflow(MIsrc)
        #fi 
      #fi  
        ) ~> 

    setFlag(
      #ifMInt zeroMInt(MIcount)
      #then
        getFlag("AF", RSMap)
      #else
        undef
      #fi  
        , 
        "AF") ~> 

    setFlag(
      #ifMInt zeroMInt(MIcount)
      #then
        getFlag("CF", RSMap)
      #else
        #ifMInt eqMInt(MIcount, mi(bitwidthMInt(MIcount),1))
        #then
          getSignBit(MIsrc)
        #else
          #ifMInt ultMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))
          #then
            getSignBit(shlMInt(MIsrc, uvalueMInt(MIcount) -Int 1))
          #else  
            undef
          #fi  
        #fi 
      #fi  
        , 
        "CF") ~> 

    updateParityFlag(
      #ifMInt zeroMInt(MIcount)
      #then
        #ifMInt eqMInt( getFlag("PF", RSMap), mi(1, 1)) 
        #then
          mi(64, 0)
        #else
          mi(64, 1)
        #fi  
      #else
        #ifMInt  ultMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))
        #then
          shlMInt(MIsrc, uvalueMInt(MIcount))
        #else 
          salOverflow(MIsrc)
        #fi 
      #fi  
        ) ~> 

    setRegisterValue(
      #ifMInt  ultMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))
      #then
        shlMInt(MIsrc, uvalueMInt(MIcount))
      #else 
        salOverflow(MIsrc)
      #fi 
      , R) 
  ...</k>
    <regstate> RSMap </regstate>

  /*
  // If MIcount == 0, no flags are affected
  rule
  execinstr(salq  (_,  (MIsrc, MIcount, .Typedoperands)) ) => .
    requires zeroMInt(MIcount)
    
  // If MIcount == 1
  rule
  execinstr(salq  (R,  (MIsrc, MIcount, .Typedoperands)) ) => 
    execinstr(salq  (R,  (MIsrc, MIcount, shiftLeft(MIsrc, 1), .Typedoperands)) ) 
  requires eqMInt(MIcount, mi(bitwidthMInt(MIcount),1))

  rule
  execinstr(salq  (R,  (MIsrc, MIcount, MIresult, .Typedoperands)) ) =>
      setFlag(xorMInt(getSignBit(MIsrc), getSignBit(MIresult)), "OF") ~> 
      updateZeroFlag(MIresult) ~> 
      updateSignFlag(MIresult) ~> 
      setFlag(undef, "AF") ~> 
      setFlag(getSignBit(MIsrc), "CF") ~> 
      updateParityFlag(MIresult) ~> 
      setRegisterValue(MIresult, R) 
    requires eqMInt(MIcount, mi(bitwidthMInt(MIcount),1))
  
  // If MIcount < bitwidth(MIsrc)
  rule
  execinstr(salq  (R,  (MIsrc, MIcount, .Typedoperands)) ) =>
    execinstr(salq  (R,  (MIsrc, MIcount, shiftLeft(MIsrc, 
              uvalueMInt(MIcount) -Int 1), shiftLeft(MIsrc, uvalueMInt(MIcount)), .Typedoperands)) ) 
      requires  notBool zeroMInt(MIcount) andBool 
                neMInt(MIcount, mi(bitwidthMInt(MIcount),1)) andBool 
                ultMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))

  rule
  execinstr(salq  (R,  (MIsrc, MIcount, MIintermed, MIresult, .Typedoperands)) ) =>
      setFlag(undef, "OF") ~> 
      updateZeroFlag(MIresult) ~> 
      updateSignFlag(MIresult) ~> 
      setFlag(undef, "AF") ~> 
      setFlag(getSignBit(MIintermed), "CF") ~> 
      updateParityFlag(MIresult) ~> 
      setRegisterValue(MIresult, R) 
    requires  notBool zeroMInt(MIcount) andBool 
              neMInt(MIcount, mi(bitwidthMInt(MIcount),1)) andBool 
              ultMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))


  // If MIcount >= bitwidth(MIsrc)
  rule
  execinstr(salq  (R,  (MIsrc, MIcount, .Typedoperands)) ) =>
    execinstr(salq  (R,  (MIsrc, MIcount, salOverflow(MIsrc),  .Typedoperands)) )
      requires  notBool zeroMInt(MIcount) andBool 
                neMInt(MIcount, mi(bitwidthMInt(MIcount),1)) andBool 
                ugeMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))

  rule
  execinstr(salq  (R,  (MIsrc, MIcount, MIresult, .Typedoperands)) ) =>
      setFlag(undef, "OF") ~> 
      updateZeroFlag(MIresult) ~> 
      updateSignFlag(MIresult) ~> 
      setFlag(undef, "AF") ~> 
      // Intel manual is not clear about carry Flag
      // if MIcount == bitwidth; CF == extractMask(Misrc, 1, 0); else CF == 0
      setFlag(undef, "CF") ~> 
      updateParityFlag(MIresult) ~> 
      setRegisterValue(MIresult, R) 
      requires  notBool zeroMInt(MIcount) andBool 
                neMInt(MIcount, mi(bitwidthMInt(MIcount),1)) andBool 
                ugeMInt(MIcount, mi(bitwidthMInt(MIcount),bitwidthMInt(MIsrc)))
  */
endmodule

module SAL-SEMANTICS
  imports  SAL-R64-CL
endmodule
