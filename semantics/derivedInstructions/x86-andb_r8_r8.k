// Autogenerated using stratification.
requires "x86-configuration.k"

module ANDB-R8-R8
  imports X86-CONFIGURATION

  rule <k>
    execinstr (andb R1:R8, R2:R8,  .Operands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
 "CF" |-> (mi(1, 0) )

 "SF" |-> (xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 33), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 33), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 33), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 33)))) )

 "AF" |-> (undef)

 "PF" |-> ((#ifMInt ( (  ( countOnes(xorMInt(extractMInt(getParentValue(R2, RSMap), 56, 64), xorMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), orMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), extractMInt(getParentValue(R2, RSMap), 56, 64)))), 0)  &Int  1 )  ==K  0 )  ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)  )

 "OF" |-> (mi(1, 0) )

convToRegKeys(R2) |-> (concatenateMInt(extractMInt(getParentValue(R2, RSMap), 0, 56), xorMInt(extractMInt(getParentValue(R2, RSMap), 56, 64), xorMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), orMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), extractMInt(getParentValue(R2, RSMap), 56, 64))))) )

 "ZF" |-> ((#ifMInt (eqMInt(xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 64), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 64), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 64), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 64)))), mi(32, 0)) ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)    )


)

    </regstate>
endmodule

module ANDB-R8-R8-SEMANTICS
  imports ANDB-R8-R8
endmodule
/*
TargetInstr:
andb %cl, %bl
RWSet:
maybe read:{ %cl %bl }
must read:{ %cl %bl }
maybe write:{ %bl %cf %pf %zf %sf %of }
must write:{ %bl %cf %pf %zf %sf %of }
maybe undef:{ %af }
must undef:{ %af }
required flags:{ }

Circuit:
circuit:movsbq %bl, %r12  #  1     0    4      OPC=movsbq_r64_r8
circuit:movsbl %cl, %ebx  #  2     0x4  3      OPC=movsbl_r32_r8
circuit:andl %r12d, %ebx  #  3     0x7  3      OPC=andl_r32_r32
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

andb %cl, %bl

  maybe read:      { %cl %bl }
  must read:       { %cl %bl }
  maybe write:     { %bl %cf %pf %zf %sf %of }
  must write:      { %bl %cf %pf %zf %sf %of }
  maybe undef:     { %af }
  must undef:      { %af }
  required flags:  { }

Circuits:

%rbx   : %rbx[63:8] ∘ ((%rbx[7:0] | %rcx[7:0]) ⊕ %rcx[7:0] ⊕ %rbx[7:0])

%cf    : false
%pf    : !(((%rbx[0:0] | %rcx[0:0]) ⊕ %rcx[0:0] ⊕ %rbx[0:0]) = 0x1₁ ⊕ ((%rbx[1:1] | %rcx[1:1]) ⊕ %rcx[1:1] ⊕ %rbx[1:1]) = 0x1₁ ⊕ ((%rbx[2:2] | %rcx[2:2]) ⊕ %rcx[2:2] ⊕ %rbx[2:2]) = 0x1₁ ⊕ ((%rbx[3:3] | %rcx[3:3]) ⊕ %rcx[3:3] ⊕ %rbx[3:3]) = 0x1₁ ⊕ ((%rbx[4:4] | %rcx[4:4]) ⊕ %rcx[4:4] ⊕ %rbx[4:4]) = 0x1₁ ⊕ ((%rbx[5:5] | %rcx[5:5]) ⊕ %rcx[5:5] ⊕ %rbx[5:5]) = 0x1₁ ⊕ ((%rbx[6:6] | %rcx[6:6]) ⊕ %rcx[6:6] ⊕ %rbx[6:6]) = 0x1₁ ⊕ ((%rbx[7:7] | %rcx[7:7]) ⊕ %rcx[7:7] ⊕ %rbx[7:7]) = 0x1₁)
%zf    : ((sign-extend-64(%rbx[7:0])[31:0] | sign-extend-64(%rcx[7:0])[31:0]) ⊕ sign-extend-64(%rcx[7:0])[31:0] ⊕ sign-extend-64(%rbx[7:0])[31:0]) = 0x0₃₂
%sf    : ((sign-extend-64(%rbx[7:0])[31:31] | sign-extend-64(%rcx[7:0])[31:31]) ⊕ sign-extend-64(%rcx[7:0])[31:31] ⊕ sign-extend-64(%rbx[7:0])[31:31]) = 0x1₁
%of    : false

sigfpe  : sigfpe
sigbus  : sigbus
sigsegv : sigsegv

*/