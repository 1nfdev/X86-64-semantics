// Autogenerated using stratification.
requires "x86-configuration.k"

module ANDB-RH-RH
  imports X86-CONFIGURATION

  rule <k>
    execinstr (andb R1:Rh, R2:Rh,  .Operands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
 "CF" |-> (mi(1, 0) )

 "SF" |-> (xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 33), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 33), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 33), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 33)))) )

 "AF" |-> (undef)

 "PF" |-> ((#ifMInt ( (  ( countOnes(xorMInt(extractMInt(getParentValue(R1, RSMap), 48, 56), xorMInt(extractMInt(getParentValue(R2, RSMap), 48, 56), orMInt(extractMInt(getParentValue(R2, RSMap), 48, 56), extractMInt(getParentValue(R1, RSMap), 48, 56)))), 0)  &Int  1 )  ==K  0 )  ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)  )

 "OF" |-> (mi(1, 0) )

convToRegKeys(R2) |-> (concatenateMInt(extractMInt(getParentValue(R2, RSMap), 0, 48), concatenateMInt(xorMInt(orMInt(xorMInt(mi(8, 255), extractMInt(getParentValue(R2, RSMap), 48, 56)), extractMInt(getParentValue(R1, RSMap), 48, 56)), xorMInt(mi(8, 255), extractMInt(getParentValue(R2, RSMap), 48, 56))), extractMInt(getParentValue(R2, RSMap), 56, 64))) )

 "ZF" |-> ((#ifMInt (eqMInt(xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 64), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 64), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 64), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 64)))), mi(32, 0)) ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)    )


)

    </regstate>
endmodule

module ANDB-RH-RH-SEMANTICS
  imports ANDB-RH-RH
endmodule
/*
TargetInstr:
andb %bh, %ah
RWSet:
maybe read:{ %ah %bh }
must read:{ %ah %bh }
maybe write:{ %ah %cf %pf %zf %sf %of }
must write:{ %ah %cf %pf %zf %sf %of }
maybe undef:{ %af }
must undef:{ %af }
required flags:{ }

Circuit:
circuit:movsbw %ah, %dx  #  1     0    4      OPC=movsbw_r16_rh
circuit:andb %bh, %dl    #  2     0x4  2      OPC=andb_r8_rh
circuit:xchgb %ah, %dl   #  3     0x6  2      OPC=xchgb_r8_rh
circuit:testb %bh, %dl   #  4     0x8  2      OPC=testb_r8_rh
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

andb %bh, %ah

  maybe read:      { %ah %bh }
  must read:       { %ah %bh }
  maybe write:     { %ah %cf %pf %zf %sf %of }
  must write:      { %ah %cf %pf %zf %sf %of }
  maybe undef:     { %af }
  must undef:      { %af }
  required flags:  { }

Circuits:

%rax   : %rax[63:16] ∘ (%rax[15:8] ⊕ 0xff₈ ⊕ (%rbx[15:8] | %rax[15:8] ⊕ 0xff₈)) ∘ %rax[7:0]

%cf    : false
%pf    : !(((%rbx[8:8] | %rax[8:8]) ⊕ %rax[8:8] ⊕ %rbx[8:8]) = 0x1₁ ⊕ ((%rbx[9:9] | %rax[9:9]) ⊕ %rax[9:9] ⊕ %rbx[9:9]) = 0x1₁ ⊕ ((%rbx[10:10] | %rax[10:10]) ⊕ %rax[10:10] ⊕ %rbx[10:10]) = 0x1₁ ⊕ ((%rbx[11:11] | %rax[11:11]) ⊕ %rax[11:11] ⊕ %rbx[11:11]) = 0x1₁ ⊕ ((%rbx[12:12] | %rax[12:12]) ⊕ %rax[12:12] ⊕ %rbx[12:12]) = 0x1₁ ⊕ ((%rbx[13:13] | %rax[13:13]) ⊕ %rax[13:13] ⊕ %rbx[13:13]) = 0x1₁ ⊕ ((%rbx[14:14] | %rax[14:14]) ⊕ %rax[14:14] ⊕ %rbx[14:14]) = 0x1₁ ⊕ ((%rbx[15:15] | %rax[15:15]) ⊕ %rax[15:15] ⊕ %rbx[15:15]) = 0x1₁)
%zf    : ((sign-extend-64(%rbx[15:8])[31:0] | sign-extend-64(%rax[15:8])[31:0]) ⊕ sign-extend-64(%rax[15:8])[31:0] ⊕ sign-extend-64(%rbx[15:8])[31:0]) = 0x0₃₂
%sf    : ((sign-extend-64(%rbx[15:8])[31:31] | sign-extend-64(%rax[15:8])[31:31]) ⊕ sign-extend-64(%rax[15:8])[31:31] ⊕ sign-extend-64(%rbx[15:8])[31:31]) = 0x1₁
%of    : false

sigfpe  : sigfpe
sigbus  : sigbus
sigsegv : sigsegv

*/