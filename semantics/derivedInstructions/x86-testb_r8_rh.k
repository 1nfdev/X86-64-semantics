// Autogenerated using stratification.
requires "x86-configuration.k"

module TESTB-R8-RH
  imports X86-CONFIGURATION

  rule <k>
    execinstr (testb R1:Rh, R2:R8,  .Operands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
 "CF" |-> (mi(1, 0) )

 "SF" |-> (xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 33), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 33), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 33), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 33)))) )

 "AF" |-> (undef)

 "PF" |-> ((#ifMInt ( (  ( countOnes(xorMInt(extractMInt(getParentValue(R1, RSMap), 48, 56), xorMInt(extractMInt(getParentValue(R2, RSMap), 56, 64), orMInt(extractMInt(getParentValue(R2, RSMap), 56, 64), extractMInt(getParentValue(R1, RSMap), 48, 56)))), 0)  &Int  1 )  ==K  0 )  ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)  )

 "OF" |-> (mi(1, 0) )

 "ZF" |-> ((#ifMInt (eqMInt(xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 64), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 64), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 64), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 64)))), mi(32, 0)) ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)    )


)

    </regstate>
endmodule

module TESTB-R8-RH-SEMANTICS
  imports TESTB-R8-RH
endmodule
/*
TargetInstr:
testb %ah, %bl
RWSet:
maybe read:{ %ah %bl }
must read:{ %ah %bl }
maybe write:{ %cf %pf %zf %sf %of }
must write:{ %cf %pf %zf %sf %of }
maybe undef:{ %af }
must undef:{ %af }
required flags:{ }

Circuit:
circuit:movzbw %ah, %ax  #  1     0    4      OPC=movzbw_r16_rh
circuit:testb %bl, %al   #  2     0x4  2      OPC=testb_r8_r8
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

testb %ah, %bl

  maybe read:      { %ah %bl }
  must read:       { %ah %bl }
  maybe write:     { %cf %pf %zf %sf %of }
  must write:      { %cf %pf %zf %sf %of }
  maybe undef:     { %af }
  must undef:      { %af }
  required flags:  { }

Circuits:

%cf    : false
%pf    : !(((%rax[8:8] | %rbx[0:0]) ⊕ %rbx[0:0] ⊕ %rax[8:8]) = 0x1₁ ⊕ ((%rax[9:9] | %rbx[1:1]) ⊕ %rbx[1:1] ⊕ %rax[9:9]) = 0x1₁ ⊕ ((%rax[10:10] | %rbx[2:2]) ⊕ %rbx[2:2] ⊕ %rax[10:10]) = 0x1₁ ⊕ ((%rax[11:11] | %rbx[3:3]) ⊕ %rbx[3:3] ⊕ %rax[11:11]) = 0x1₁ ⊕ ((%rax[12:12] | %rbx[4:4]) ⊕ %rbx[4:4] ⊕ %rax[12:12]) = 0x1₁ ⊕ ((%rax[13:13] | %rbx[5:5]) ⊕ %rbx[5:5] ⊕ %rax[13:13]) = 0x1₁ ⊕ ((%rax[14:14] | %rbx[6:6]) ⊕ %rbx[6:6] ⊕ %rax[14:14]) = 0x1₁ ⊕ ((%rax[15:15] | %rbx[7:7]) ⊕ %rbx[7:7] ⊕ %rax[15:15]) = 0x1₁)
%zf    : ((sign-extend-64(%rax[15:8])[31:0] | sign-extend-64(%rbx[7:0])[31:0]) ⊕ sign-extend-64(%rbx[7:0])[31:0] ⊕ sign-extend-64(%rax[15:8])[31:0]) = 0x0₃₂
%sf    : ((sign-extend-64(%rax[15:8])[31:31] | sign-extend-64(%rbx[7:0])[31:31]) ⊕ sign-extend-64(%rbx[7:0])[31:31] ⊕ sign-extend-64(%rax[15:8])[31:31]) = 0x1₁
%of    : false

sigfpe  : sigfpe
sigbus  : sigbus
sigsegv : sigsegv

*/