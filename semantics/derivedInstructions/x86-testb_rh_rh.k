// Autogenerated using stratification.
requires "x86-configuration.k"

module TESTB-RH-RH
  imports X86-CONFIGURATION

  rule <k>
    execinstr (testb R1:Rh, R2:Rh,  .Operands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
 "CF" |-> (mi(1, 0) )

 "SF" |-> (xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 33), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 33), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 33), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 33)))) )

 "AF" |-> (undef)

 "PF" |-> ((#ifMInt ( (  ( countOnes(xorMInt(extractMInt(getParentValue(R1, RSMap), 48, 56), xorMInt(extractMInt(getParentValue(R2, RSMap), 48, 56), orMInt(extractMInt(getParentValue(R2, RSMap), 48, 56), extractMInt(getParentValue(R1, RSMap), 48, 56)))), 0)  &Int  1 )  ==K  0 )  ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)  )

 "OF" |-> (mi(1, 0) )

 "ZF" |-> ((#ifMInt (eqMInt(xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 64), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 64), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 64), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 56))), 32, 64)))), mi(32, 0)) ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)    )


)

    </regstate>
endmodule

module TESTB-RH-RH-SEMANTICS
  imports TESTB-RH-RH
endmodule
/*
TargetInstr:
testb %bh, %ah
RWSet:
maybe read:{ %ah %bh }
must read:{ %ah %bh }
maybe write:{ %cf %pf %zf %sf %of }
must write:{ %cf %pf %zf %sf %of }
maybe undef:{ %af }
must undef:{ %af }
required flags:{ }

Circuit:
circuit:movzbl %ah, %eax  #  1     0    3      OPC=movzbl_r32_rh
circuit:testb %bh, %al    #  2     0x3  2      OPC=testb_r8_rh
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

testb %bh, %ah

  maybe read:      { %ah %bh }
  must read:       { %ah %bh }
  maybe write:     { %cf %pf %zf %sf %of }
  must write:      { %cf %pf %zf %sf %of }
  maybe undef:     { %af }
  must undef:      { %af }
  required flags:  { }

Circuits:

%cf    : false
%pf    : !(((%rbx[8:8] | %rax[8:8]) ⊕ %rax[8:8] ⊕ %rbx[8:8]) = 0x1₁ ⊕ ((%rbx[9:9] | %rax[9:9]) ⊕ %rax[9:9] ⊕ %rbx[9:9]) = 0x1₁ ⊕ ((%rbx[10:10] | %rax[10:10]) ⊕ %rax[10:10] ⊕ %rbx[10:10]) = 0x1₁ ⊕ ((%rbx[11:11] | %rax[11:11]) ⊕ %rax[11:11] ⊕ %rbx[11:11]) = 0x1₁ ⊕ ((%rbx[12:12] | %rax[12:12]) ⊕ %rax[12:12] ⊕ %rbx[12:12]) = 0x1₁ ⊕ ((%rbx[13:13] | %rax[13:13]) ⊕ %rax[13:13] ⊕ %rbx[13:13]) = 0x1₁ ⊕ ((%rbx[14:14] | %rax[14:14]) ⊕ %rax[14:14] ⊕ %rbx[14:14]) = 0x1₁ ⊕ ((%rbx[15:15] | %rax[15:15]) ⊕ %rax[15:15] ⊕ %rbx[15:15]) = 0x1₁)
%zf    : ((sign-extend-64(%rbx[15:8])[31:0] | sign-extend-64(%rax[15:8])[31:0]) ⊕ sign-extend-64(%rax[15:8])[31:0] ⊕ sign-extend-64(%rbx[15:8])[31:0]) = 0x0₃₂
%sf    : ((sign-extend-64(%rbx[15:8])[31:31] | sign-extend-64(%rax[15:8])[31:31]) ⊕ sign-extend-64(%rax[15:8])[31:31] ⊕ sign-extend-64(%rbx[15:8])[31:31]) = 0x1₁
%of    : false

sigfpe  : sigfpe
sigbus  : sigbus
sigsegv : sigsegv

*/