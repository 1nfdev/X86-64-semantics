// Autogenerated using stratification.
requires "x86-configuration.k"

module TESTB-R8-R8
  imports X86-CONFIGURATION

  rule <k>
    execinstr (testb R1:R8, R2:R8,  .Typedoperands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
 "CF" |-> (mi(1, 0) )

 "SF" |-> (xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 33), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 33), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 33), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 33)))) )

 "AF" |-> (undef)

 "PF" |-> ((#ifMInt ( (  ( countOnes(xorMInt(extractMInt(getParentValue(R2, RSMap), 56, 64), xorMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), orMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), extractMInt(getParentValue(R2, RSMap), 56, 64)))), 0)  &Int  1 )  ==K  0 )  ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)  )

 "OF" |-> (mi(1, 0) )

 "ZF" |-> ((#ifMInt (eqMInt(xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 64), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 64), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 64), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 56, 64))), 32, 64)))), mi(32, 0)) ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)    )


)

    </regstate>
endmodule

module TESTB-R8-R8-SEMANTICS
  imports TESTB-R8-R8
endmodule
/*
TargetInstr:
testb %cl, %bl
RWSet:
maybe read:{ %cl %bl }
must read:{ %cl %bl }
maybe write:{ %cf %pf %zf %sf %of }
must write:{ %cf %pf %zf %sf %of }
maybe undef:{ %af }
must undef:{ %af }
required flags:{ }

Circuit:
circuit:movsbl %bl, %ebx   #  1     0    3      OPC=movsbl_r32_r8
circuit:movsbl %cl, %r11d  #  2     0x3  4      OPC=movsbl_r32_r8
circuit:testl %r11d, %ebx  #  3     0x7  3      OPC=testl_r32_r32
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

testb %cl, %bl

  maybe read:      { %cl %bl }
  must read:       { %cl %bl }
  maybe write:     { %cf %pf %zf %sf %of }
  must write:      { %cf %pf %zf %sf %of }
  maybe undef:     { %af }
  must undef:      { %af }
  required flags:  { }

Circuits:

%cf    : FALSE
%pf    : (not (xor (xor (xor (xor (xor (xor (xor (== (^ (^ (| <%rbx|64>[0:0] <%rcx|64>[0:0]) <%rcx|64>[0:0]) <%rbx|64>[0:0]) <0x1|1>) (== (^ (^ (| <%rbx|64>[1:1] <%rcx|64>[1:1]) <%rcx|64>[1:1]) <%rbx|64>[1:1]) <0x1|1>)) (== (^ (^ (| <%rbx|64>[2:2] <%rcx|64>[2:2]) <%rcx|64>[2:2]) <%rbx|64>[2:2]) <0x1|1>)) (== (^ (^ (| <%rbx|64>[3:3] <%rcx|64>[3:3]) <%rcx|64>[3:3]) <%rbx|64>[3:3]) <0x1|1>)) (== (^ (^ (| <%rbx|64>[4:4] <%rcx|64>[4:4]) <%rcx|64>[4:4]) <%rbx|64>[4:4]) <0x1|1>)) (== (^ (^ (| <%rbx|64>[5:5] <%rcx|64>[5:5]) <%rcx|64>[5:5]) <%rbx|64>[5:5]) <0x1|1>)) (== (^ (^ (| <%rbx|64>[6:6] <%rcx|64>[6:6]) <%rcx|64>[6:6]) <%rbx|64>[6:6]) <0x1|1>)) (== (^ (^ (| <%rbx|64>[7:7] <%rcx|64>[7:7]) <%rcx|64>[7:7]) <%rbx|64>[7:7]) <0x1|1>)))
%zf    : (== (^ (^ (| (sign-extend-64 <%rbx|64>[7:0])[31:0] (sign-extend-64 <%rcx|64>[7:0])[31:0]) (sign-extend-64 <%rcx|64>[7:0])[31:0]) (sign-extend-64 <%rbx|64>[7:0])[31:0]) <0x0|32>)
%sf    : (== (^ (^ (| (sign-extend-64 <%rbx|64>[7:0])[31:31] (sign-extend-64 <%rcx|64>[7:0])[31:31]) (sign-extend-64 <%rcx|64>[7:0])[31:31]) (sign-extend-64 <%rbx|64>[7:0])[31:31]) <0x1|1>)
%of    : FALSE

sigfpe  : <sigfpe>
sigbus  : <sigbus>
sigsegv : <sigsegv>

*/