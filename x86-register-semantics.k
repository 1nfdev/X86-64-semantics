requires "x86-syntax.k"
requires "x86-configuration.k"
requires "x86-general-utils.k"

module X86-FLAG-CHECKS
  imports X86-SYNTAX
  imports X86-CONFIGURATION
  imports X86-GENERAL-UTILS

  /*@
    http://teaching.idallen.com/dat2343/10f/notes/040_overflow.txt
  */  
  
  /*@
    Update Overflow Flag.
  */  
  syntax KItem ::= updateOverflowAdd(MInt, MInt, MInt) 

  rule 
  <k> updateOverflowAdd(MIsrc1, MIsrc2, MIres) => . ...</k>
  <of> _ => fromBool( 
              eqMInt( 
                mi(bitwidthMInt(MIres),2), 
                addMInt(
                  xorMInt(
                    lshrMInt(MIsrc1, bitwidthMInt(MIres) -Int 1),
                    lshrMInt(MIres, bitwidthMInt(MIres) -Int 1)
                  ),
                  xorMInt(
                    lshrMInt(MIsrc2, bitwidthMInt(MIres) -Int 1),
                    lshrMInt(MIres, bitwidthMInt(MIres) -Int 1)
                  )
                )
              ) 
            , 1)
  </of>


  /*@
    Update Zero Flag.
  */  
  syntax KItem ::= updateZeroFlag(MInt) 
  rule 
  <k> updateZeroFlag(MI) => . ...</k>
  <zf> _ => fromBool(zeroMInt(MI),1) </zf>

  /*@
    Update Sign Flag.
  */  
  syntax KItem ::= updateSignFlag(MInt) 
  rule 
  <k> updateSignFlag(MI) => . ...</k>
  <sf> _ => fromBool( 
              eqMInt(
                mi(bitwidthMInt(MI),1), 
                lshrMInt(MI, bitwidthMInt(MI) -Int 1)) , 
              1) 
  </sf>

  /*@
    Update AuxCarry Flag.
  */  
  syntax KItem ::= updateAuxCarryFlag(MInt,MInt, MInt) 
  rule <k> updateAuxCarryFlag(MIsrc1, MIsrc2, MIres) => . ...</k>
  <af> _ =>  fromBool( 
              toBool(  
                andMInt( 
                  lshrMInt(
                    xorMInt( xorMInt( MIsrc1, MIsrc2), MIres), 
                    4
                  ),
                  mi(bitwidthMInt(MIres), 1)
                )
              )    
            , 1)
  </af>

  /*@
    Update Carry Flag.
  */  
  syntax Bool ::= carryHelperAdd(MInt,MInt, MInt) [function]
  rule  carryHelperAdd(MIsrc1, MIsrc2, MIres) => 
      ultMInt( MIres, MIsrc1) orBool ultMInt( MIres, MIsrc2)

  syntax KItem ::= updateCarryFlagAdd(MInt,MInt, MInt, MInt, MInt) 
  rule <k> updateCarryFlagAdd(MIsrc1, MIsrc2, MIsum, MIcarry, MIresult) => . ...</k>
  <cf> _ => fromBool( carryHelperAdd(MIsrc1, MIsrc2, MIsum) orBool carryHelperAdd(MIsum, MIcarry, MIresult) , 1)
  </cf>

  /*@
    Update Parity Flag.
  */  
  syntax KItem ::= updateParityFlag(MInt) 
  rule <k> updateParityFlag(MI:MInt) => . ...</k>
  <pf> _ => 
          fromBool(
            toBool(
              xorMInt(
                andMInt(
                  addListMInt(
                      32,
                      fromBool(toBool(andMInt(MI, mi(bitwidthMInt(MI),1))), 32)
                      fromBool(toBool(andMInt(MI, mi(bitwidthMInt(MI),2))), 32)
                      fromBool(toBool(andMInt(MI, mi(bitwidthMInt(MI),4))), 32)
                      fromBool(toBool(andMInt(MI, mi(bitwidthMInt(MI),8))), 32)
                      fromBool(toBool(andMInt(MI, mi(bitwidthMInt(MI),16))), 32)
                      fromBool(toBool(andMInt(MI, mi(bitwidthMInt(MI),32))), 32)
                      fromBool(toBool(andMInt(MI, mi(bitwidthMInt(MI),64))), 32)
                      fromBool(toBool(andMInt(MI, mi(bitwidthMInt(MI),128))), 32)
                  ), 
                  mi(32,1)),
                mi(32,1))
            ), 
          1)
  </pf>


  /*@
    Setting the flags with 0 or 1.
  */
  syntax KItem ::= setOverflow(MInt) 
  syntax KItem ::= setZeroFlag(MInt) 
  syntax KItem ::= setSignFlag(MInt) 
  syntax KItem ::= setAuxCarryFlag(MInt) 
  syntax KItem ::= setCarryFlag(MInt) 
  syntax KItem ::= setParityFlag(MInt) 

  rule 
  <k> setOverflow(MI) => . ...</k>
  <of> _ => MI </of>

  rule 
  <k> setZeroFlag(MI) => . ...</k>
  <zf> _ => MI </zf>

  rule 
  <k> setSignFlag(MI) => . ...</k>
  <sf> _ => MI </sf>

  rule 
  <k> setAuxCarryFlag(MI) => . ...</k>
  <af> _ => MI </af>

  rule 
  <k> setCarryFlag(MI) => . ...</k>
  <cf> _ => MI </cf>

  rule 
  <k> setParityFlag(MI) => . ...</k>
  <pf> _ => MI </pf>

endmodule  

module X86-REGISTER-SEMANTICS
  imports X86-FLAG-CHECKS
  //imports X86-REGISTER-OPERATIONS
  imports X86-SYNTAX
  imports X86-CONFIGURATION
  imports X86-GENERAL-UTILS

  /*@
    if the top computational task is to update a register, say Rd with a computed
    value I, the previous value of Rd, denoted by the wildcard _, is replaced by
    I, as shown below.
  */
  syntax KItem ::= updateReg(K, Register) [strict(1)]

  /*@  
    extractLSBitsFromRegister(R, M): Extracts the lower M bits from a R register.
    Todo : type check
  */
  syntax Typeoperand ::= extractLSBitsFromRegister(R64,Int)
  syntax Typeoperand ::= MInt

  /*@ pluginLSBitsToRegister(MI, R): plugin MI == mi(M, I) to lower M bits of R. 
  */  
  syntax MInt ::= pluginLSBitsToRegister(MInt, R64)

  // Autogenerated 
  rule <k> %rax => MI ...</k> <rax> MI </rax>
  rule <k> %rbx => MI ...</k> <rbx> MI </rbx>
  rule <k> %rcx => MI ...</k> <rcx> MI </rcx>
  rule <k> %rdx => MI ...</k> <rdx> MI </rdx>
  rule <k> %rsi => MI ...</k> <rsi> MI </rsi>
  rule <k> %rdi => MI ...</k> <rdi> MI </rdi>
  rule <k> %rsp => MI ...</k> <rsp> MI </rsp>
  rule <k> %rbp => MI ...</k> <rbp> MI </rbp>
  rule <k> %r8 => MI ...</k> <r8> MI </r8>
  rule <k> %r9 => MI ...</k> <r9> MI </r9>
  rule <k> %r10 => MI ...</k> <r10> MI </r10>
  rule <k> %r11 => MI ...</k> <r11> MI </r11>
  rule <k> %r12 => MI ...</k> <r12> MI </r12>
  rule <k> %r13 => MI ...</k> <r13> MI </r13>
  rule <k> %r14 => MI ...</k> <r14> MI </r14>
  rule <k> %r15 => MI ...</k> <r15> MI </r15>


  rule <k> updateReg(MI:MInt, %rax) => . ...</k> <rax> _ => MI </rax>
  rule <k> updateReg(MI:MInt, %rbx) => . ...</k> <rbx> _ => MI </rbx>
  rule <k> updateReg(MI:MInt, %rcx) => . ...</k> <rcx> _ => MI </rcx>
  rule <k> updateReg(MI:MInt, %rdx) => . ...</k> <rdx> _ => MI </rdx>
  rule <k> updateReg(MI:MInt, %rsi) => . ...</k> <rsi> _ => MI </rsi>
  rule <k> updateReg(MI:MInt, %rdi) => . ...</k> <rdi> _ => MI </rdi>
  rule <k> updateReg(MI:MInt, %rsp) => . ...</k> <rsp> _ => MI </rsp>
  rule <k> updateReg(MI:MInt, %rbp) => . ...</k> <rbp> _ => MI </rbp>
  rule <k> updateReg(MI:MInt, %r8) => . ...</k> <r8> _ => MI </r8>
  rule <k> updateReg(MI:MInt, %r9) => . ...</k> <r9> _ => MI </r9>
  rule <k> updateReg(MI:MInt, %r10) => . ...</k> <r10> _ => MI </r10>
  rule <k> updateReg(MI:MInt, %r11) => . ...</k> <r11> _ => MI </r11>
  rule <k> updateReg(MI:MInt, %r12) => . ...</k> <r12> _ => MI </r12>
  rule <k> updateReg(MI:MInt, %r13) => . ...</k> <r13> _ => MI </r13>
  rule <k> updateReg(MI:MInt, %r14) => . ...</k> <r14> _ => MI </r14>
  rule <k> updateReg(MI:MInt, %r15) => . ...</k> <r15> _ => MI </r15>


  rule <k> extractLSBitsFromRegister(%rax, 8) => truncate(MI,64,8) ...</k>
  <rax> MI </rax>
  rule <k> extractLSBitsFromRegister(%rbx, 8) => truncate(MI,64,8) ...</k>
  <rbx> MI </rbx>
  rule <k> extractLSBitsFromRegister(%rcx, 8) => truncate(MI,64,8) ...</k>
  <rcx> MI </rcx>
  rule <k> extractLSBitsFromRegister(%rdx, 8) => truncate(MI,64,8) ...</k>
  <rdx> MI </rdx>
  rule <k> extractLSBitsFromRegister(%rsi, 8) => truncate(MI,64,8) ...</k>
  <rsi> MI </rsi>
  rule <k> extractLSBitsFromRegister(%rdi, 8) => truncate(MI,64,8) ...</k>
  <rdi> MI </rdi>
  rule <k> extractLSBitsFromRegister(%rsp, 8) => truncate(MI,64,8) ...</k>
  <rsp> MI </rsp>
  rule <k> extractLSBitsFromRegister(%rbp, 8) => truncate(MI,64,8) ...</k>
  <rbp> MI </rbp>
  rule <k> extractLSBitsFromRegister(%r8, 8) => truncate(MI,64,8) ...</k>
  <r8> MI </r8>
  rule <k> extractLSBitsFromRegister(%r9, 8) => truncate(MI,64,8) ...</k>
  <r9> MI </r9>
  rule <k> extractLSBitsFromRegister(%r10, 8) => truncate(MI,64,8) ...</k>
  <r10> MI </r10>
  rule <k> extractLSBitsFromRegister(%r11, 8) => truncate(MI,64,8) ...</k>
  <r11> MI </r11>
  rule <k> extractLSBitsFromRegister(%r12, 8) => truncate(MI,64,8) ...</k>
  <r12> MI </r12>
  rule <k> extractLSBitsFromRegister(%r13, 8) => truncate(MI,64,8) ...</k>
  <r13> MI </r13>
  rule <k> extractLSBitsFromRegister(%r14, 8) => truncate(MI,64,8) ...</k>
  <r14> MI </r14>
  rule <k> extractLSBitsFromRegister(%r15, 8) => truncate(MI,64,8) ...</k>
  <r15> MI </r15>


  rule <k> extractLSBitsFromRegister(%rax, 16) => truncate(MI,64,16) ...</k>
  <rax> MI </rax>
  rule <k> extractLSBitsFromRegister(%rbx, 16) => truncate(MI,64,16) ...</k>
  <rbx> MI </rbx>
  rule <k> extractLSBitsFromRegister(%rcx, 16) => truncate(MI,64,16) ...</k>
  <rcx> MI </rcx>
  rule <k> extractLSBitsFromRegister(%rdx, 16) => truncate(MI,64,16) ...</k>
  <rdx> MI </rdx>
  rule <k> extractLSBitsFromRegister(%rsi, 16) => truncate(MI,64,16) ...</k>
  <rsi> MI </rsi>
  rule <k> extractLSBitsFromRegister(%rdi, 16) => truncate(MI,64,16) ...</k>
  <rdi> MI </rdi>
  rule <k> extractLSBitsFromRegister(%rsp, 16) => truncate(MI,64,16) ...</k>
  <rsp> MI </rsp>
  rule <k> extractLSBitsFromRegister(%rbp, 16) => truncate(MI,64,16) ...</k>
  <rbp> MI </rbp>
  rule <k> extractLSBitsFromRegister(%r8, 16) => truncate(MI,64,16) ...</k>
  <r8> MI </r8>
  rule <k> extractLSBitsFromRegister(%r9, 16) => truncate(MI,64,16) ...</k>
  <r9> MI </r9>
  rule <k> extractLSBitsFromRegister(%r10, 16) => truncate(MI,64,16) ...</k>
  <r10> MI </r10>
  rule <k> extractLSBitsFromRegister(%r11, 16) => truncate(MI,64,16) ...</k>
  <r11> MI </r11>
  rule <k> extractLSBitsFromRegister(%r12, 16) => truncate(MI,64,16) ...</k>
  <r12> MI </r12>
  rule <k> extractLSBitsFromRegister(%r13, 16) => truncate(MI,64,16) ...</k>
  <r13> MI </r13>
  rule <k> extractLSBitsFromRegister(%r14, 16) => truncate(MI,64,16) ...</k>
  <r14> MI </r14>
  rule <k> extractLSBitsFromRegister(%r15, 16) => truncate(MI,64,16) ...</k>
  <r15> MI </r15>


  rule <k> extractLSBitsFromRegister(%rax, 32) => truncate(MI,64,32) ...</k>
  <rax> MI </rax>
  rule <k> extractLSBitsFromRegister(%rbx, 32) => truncate(MI,64,32) ...</k>
  <rbx> MI </rbx>
  rule <k> extractLSBitsFromRegister(%rcx, 32) => truncate(MI,64,32) ...</k>
  <rcx> MI </rcx>
  rule <k> extractLSBitsFromRegister(%rdx, 32) => truncate(MI,64,32) ...</k>
  <rdx> MI </rdx>
  rule <k> extractLSBitsFromRegister(%rsi, 32) => truncate(MI,64,32) ...</k>
  <rsi> MI </rsi>
  rule <k> extractLSBitsFromRegister(%rdi, 32) => truncate(MI,64,32) ...</k>
  <rdi> MI </rdi>
  rule <k> extractLSBitsFromRegister(%rsp, 32) => truncate(MI,64,32) ...</k>
  <rsp> MI </rsp>
  rule <k> extractLSBitsFromRegister(%rbp, 32) => truncate(MI,64,32) ...</k>
  <rbp> MI </rbp>
  rule <k> extractLSBitsFromRegister(%r8, 32) => truncate(MI,64,32) ...</k>
  <r8> MI </r8>
  rule <k> extractLSBitsFromRegister(%r9, 32) => truncate(MI,64,32) ...</k>
  <r9> MI </r9>
  rule <k> extractLSBitsFromRegister(%r10, 32) => truncate(MI,64,32) ...</k>
  <r10> MI </r10>
  rule <k> extractLSBitsFromRegister(%r11, 32) => truncate(MI,64,32) ...</k>
  <r11> MI </r11>
  rule <k> extractLSBitsFromRegister(%r12, 32) => truncate(MI,64,32) ...</k>
  <r12> MI </r12>
  rule <k> extractLSBitsFromRegister(%r13, 32) => truncate(MI,64,32) ...</k>
  <r13> MI </r13>
  rule <k> extractLSBitsFromRegister(%r14, 32) => truncate(MI,64,32) ...</k>
  <r14> MI </r14>
  rule <k> extractLSBitsFromRegister(%r15, 32) => truncate(MI,64,32) ...</k>
  <r15> MI </r15>


  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %rax) =>
      updateReg(updateLSB(MId, MIs), %rax) ...</k>
  <rax> MId </rax>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %rbx) =>
      updateReg(updateLSB(MId, MIs), %rbx) ...</k>
  <rbx> MId </rbx>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %rcx) =>
      updateReg(updateLSB(MId, MIs), %rcx) ...</k>
  <rcx> MId </rcx>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %rdx) =>
      updateReg(updateLSB(MId, MIs), %rdx) ...</k>
  <rdx> MId </rdx>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %rsi) =>
      updateReg(updateLSB(MId, MIs), %rsi) ...</k>
  <rsi> MId </rsi>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %rdi) =>
      updateReg(updateLSB(MId, MIs), %rdi) ...</k>
  <rdi> MId </rdi>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %rsp) =>
      updateReg(updateLSB(MId, MIs), %rsp) ...</k>
  <rsp> MId </rsp>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %rbp) =>
      updateReg(updateLSB(MId, MIs), %rbp) ...</k>
  <rbp> MId </rbp>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %r8) =>
      updateReg(updateLSB(MId, MIs), %r8) ...</k>
  <r8> MId </r8>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %r9) =>
      updateReg(updateLSB(MId, MIs), %r9) ...</k>
  <r9> MId </r9>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %r10) =>
      updateReg(updateLSB(MId, MIs), %r10) ...</k>
  <r10> MId </r10>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %r11) =>
      updateReg(updateLSB(MId, MIs), %r11) ...</k>
  <r11> MId </r11>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %r12) =>
      updateReg(updateLSB(MId, MIs), %r12) ...</k>
  <r12> MId </r12>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %r13) =>
      updateReg(updateLSB(MId, MIs), %r13) ...</k>
  <r13> MId </r13>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %r14) =>
      updateReg(updateLSB(MId, MIs), %r14) ...</k>
  <r14> MId </r14>
  rule <k> 
    pluginLSBitsToRegister(MIs:MInt, %r15) =>
      updateReg(updateLSB(MId, MIs), %r15) ...</k>
  <r15> MId </r15>


endmodule
