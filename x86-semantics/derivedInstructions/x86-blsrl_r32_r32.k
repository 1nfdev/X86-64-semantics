// Autogenerated using stratification.
requires "x86-configuration.k"

module BLSRL-R32-R32
  imports X86-CONFIGURATION

  rule <k>
    execinstr (blsrl R1:R32, R2:R32,  .Typedoperands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
 "CF" |-> (extractMInt(addMInt(concatenateMInt(mi(1, 0), extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 17, 25)), concatenateMInt(mi(1, 0), extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 17, 25))), 0, 1) )

 "SF" |-> (xorMInt(extractMInt(getParentValue(R1, RSMap), 32, 33), xorMInt(extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 33, 34), orMInt(extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 33, 34), extractMInt(getParentValue(R1, RSMap), 32, 33)))) )

 "AF" |-> (undef)

 "PF" |-> (undef)

 "OF" |-> ((#ifMInt ( ( eqMInt(extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 17, 18), extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 17, 18))  andBool   notBool  ( eqMInt(extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 17, 18), extractMInt(addMInt(concatenateMInt(mi(1, 0), extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 17, 25)), concatenateMInt(mi(1, 0), extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 17, 25))), 1, 2)) )  )  ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)  )

convToRegKeys(R2) |-> (concatenateMInt(mi(32, 0), xorMInt(extractMInt(getParentValue(R1, RSMap), 32, 64), xorMInt(extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 33, 65), orMInt(extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 33, 65), extractMInt(getParentValue(R1, RSMap), 32, 64))))) )

 "ZF" |-> ((#ifMInt (eqMInt(xorMInt(extractMInt(getParentValue(R1, RSMap), 32, 64), xorMInt(extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 33, 65), orMInt(extractMInt(addMInt(mi(65, 18446744073709551615), concatenateMInt(mi(33, 0), extractMInt(getParentValue(R1, RSMap), 32, 64))), 33, 65), extractMInt(getParentValue(R1, RSMap), 32, 64)))), mi(32, 0)) ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)    )


)

    </regstate>
endmodule

module BLSRL-R32-R32-SEMANTICS
  imports BLSRL-R32-R32
endmodule
/*
TargetInstr:
blsrl %ecx, %ebx
RWSet:
maybe read:{ %ecx }
must read:{ %ecx }
maybe write:{ %rbx %cf %zf %sf %of }
must write:{ %rbx %cf %zf %sf %of }
maybe undef:{ %pf %af }
must undef:{ %pf %af }
required flags:{ bmi1 }

Circuit:
circuit:movl %ecx, %ebx         #  1     0     2      OPC=movl_r32_r32
circuit:decq %rbx               #  2     0x2   3      OPC=decq_r64
circuit:andl %ecx, %ebx         #  3     0x5   2      OPC=andl_r32_r32
circuit:blsmskl %ecx, %ecx      #  4     0x7   5      OPC=blsmskl_r32_r32
circuit:callq .set_szp_for_ebx  #  5     0xc   5      OPC=callq_label
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

blsrl %ecx, %ebx

  maybe read:      { %ecx }
  must read:       { %ecx }
  maybe write:     { %rbx %cf %zf %sf %of }
  must write:      { %rbx %cf %zf %sf %of }
  maybe undef:     { %pf %af }
  must undef:      { %pf %af }
  required flags:  { bmi1 }

Circuits:

%rbx   : 0x0₃₂ ∘ ((%rcx[31:0] | (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[31:0]) ⊕ (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[31:0] ⊕ %rcx[31:0])

%cf    : (0x0₁ ∘ (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[47:40] + 0x0₁ ∘ (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[47:40])[8:8] = 0x1₁
%zf    : ((%rcx[31:0] | (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[31:0]) ⊕ (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[31:0] ⊕ %rcx[31:0]) = 0x0₃₂
%sf    : ((%rcx[31:31] | (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[31:31]) ⊕ (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[31:31] ⊕ %rcx[31:31]) = 0x1₁
%of    : ((0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[47:47] = 0x1₁ ↔ (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[47:47] = 0x1₁) ∧ !((0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[47:47] = 0x1₁ ↔ (0x0₁ ∘ (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[47:40] + 0x0₁ ∘ (0x0₁ ∘ 0xffffffffffffffff₆₄ + 0x0₁ ∘ (0x0₃₂ ∘ %rcx[31:0]))[47:40])[7:7] = 0x1₁)

sigfpe  : sigfpe
sigbus  : sigbus
sigsegv : sigsegv

*/