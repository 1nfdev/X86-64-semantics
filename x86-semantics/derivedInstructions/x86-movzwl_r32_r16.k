// Autogenerated using stratification.
requires "x86-configuration.k"

module MOVZWL-R32-R16
  imports X86-CONFIGURATION

  rule <k>
    execinstr (movzwl R1:R16, R2:R32,  .Typedoperands) => .
  ...</k>
    <regstate> 
RSMap:Map => updateMap(RSMap,

convToRegKeys(R2) |-> (concatenateMInt(mi(48, 0), extractMInt(getParentValue(R1, RSMap), 48, 64)) )



)
    </regstate>
endmodule

module MOVZWL-R32-R16-SEMANTICS
  imports MOVZWL-R32-R16
endmodule


/*circuit:movq $0x20, %rbx                  #  1     0     10     OPC=movq_r64_imm64
circuit:callq .move_016_008_cx_r12b_r13b  #  2     0xa   5      OPC=callq_label
circuit:callq .move_008_016_r12b_r13b_bx  #  3     0xf   5      OPC=callq_label


maybe read:{ %cx }
must read:{ %cx }
maybe write:{ %rbx }
must write:{ %rbx }
maybe undef:{ }
must undef:{ }
required flags:{ }


WARNING: No live out values provided, assuming { }

WARNING: No def in values provided; assuming { %mxcsr::rc[0] }

Target



movzwl %cx, %ebx



  maybe read:      { %cx }

  must read:       { %cx }

  maybe write:     { %rbx }

  must write:      { %rbx }

  maybe undef:     { }

  must undef:      { }

  required flags:  { }



-------------------------------------

Getting base circuit for movq $0x20, %rbx



Final state:

%rbx/%rbx: 0x20₆₄



-------------------------------------

-------------------------------------

Getting base circuit for callq .move_016_008_cx_r12b_r13b



Final state:

%rax/%rax: %rax_movzwl_r32_r16

%rdx/%rdx: %rdx_movzwl_r32_r16



%xmm0: %ymm0_movzwl_r32_r16[127:0]

%xmm1: %ymm1_movzwl_r32_r16[127:0]



-------------------------------------

-------------------------------------

Getting base circuit for callq .move_008_016_r12b_r13b_bx



Final state:

%rax/%rax: %rax_movzwl_r32_r16

%rdx/%rdx: %rdx_movzwl_r32_r16



%xmm0: %ymm0_movzwl_r32_r16[127:0]

%xmm1: %ymm1_movzwl_r32_r16[127:0]



-------------------------------------

=====================================

Computing circuit for movzwl %cx, %ebx



.target:

movq $0x20, %rbx

callq .move_016_008_cx_r12b_r13b

callq .move_008_016_r12b_r13b_bx

retq 



Initial state:

%rbx/%rbx: %rbx



State for specgen instruction: movzwl %cx, %ebx:

%rbx/%rbx: 0x20₆₄[63:16] ∘ ((%r13_movzwl_r32_r16[63:8] ∘ %rcx_movzwl_r32_r16[15:0][15:8])[7:0][7:0] ∘ (%r12_movzwl_r32_r16[63:8] ∘ %rcx_movzwl_r32_r16[15:0][7:0])[7:0][7:0])



Register        -> %rbx

  translates to => %rbx

Value is               -> 0x20₆₄[63:16] ∘ ((%r13_movzwl_r32_r16[63:8] ∘ %rcx_movzwl_r32_r16[15:0][15:8])[7:0][7:0] ∘ (%r12_movzwl_r32_r16[63:8] ∘ %rcx_movzwl_r32_r16[15:0][7:0])[7:0][7:0])

  after renaming it is => 0x0₄₈ ∘ %rcx[15:0]



Final state

%rbx/%rbx: 0x0₄₈ ∘ %rcx[15:0]



=====================================

Circuits:



%rbx   : 0x0₄₈ ∘ %rcx[15:0]



sigfpe  : sigfpe

sigbus  : sigbus

sigsegv : sigsegv

*/