\section{Modeling X86-64 Instruction Semantics}

For the purpose we used project \Strata, which automatically synthesized formal semantics  of the input/output behavior for $1796$ Haswell ISA X86-64 instructions. The key to their results is stratified synthesis, where they use a set of instructions whose semantics are known to synthesize the semantics of additional instructions whose semantics are unknown. Using the technique, they 
come up with the semantics of $692$ register variants and $\sim120$ immediate variants. The rest $\sim984$ are obtained by generalizing the register variants to memory and immediate variants.     

We borrowed the semantics of $692$ register variants. We answered the following questions to ourself before borrowing the rest.   

\begin{itemize}
    \item How reliable is the generalization of register variants to memory or immediate variants?   
    
    \item  For immediate  variants that do not have a corresponding register-only instruction, \Strata  learns a separate formula for every possible value of the constant provided the constant value is of width 8 bits. Also in some cases, they learned a formula only for some of the possible constants.
    
    In order to have a more intuitive generic semantics of those instructions, the relevant question is: How to get a generic formula for an immediate instruction for which we have separate formulas for all or a subset of constant values?   
\end{itemize} 
\ \\
\Strata covers a splendid number of $61.5\%$ of the instructions in scope. For our purpose, we aim to cover the rest. Following are the observations and conclusions that help us formulate a strategy to achieve the goal.

\paragraph{Observation \& Conclusion}
     In order to get the semantics of a target instruction {\tt I}, \Strata uses \Stoke along with set {\tt TS} of $6580$ test cases to synthesize an instruction sequence which agrees with {\tt I} on {\tt TS} (which means the output behavior of the instruction sequence matches with the real hardware execution on input {\tt TS}). After having that \emph{initial search}, they keep on searching  additional sequences (which they call {\tt secondary searches} each agreeing with {\tt I} on {\tt TS}) in a hope of getting  one which would prove non-equivalent to existing ones and thereby gaining more confidence on the search and probably a better test-suite (as {\tt TS} might get augmented with a counter example from equivalence checker in the event of non-equivalence). One unfavorable possibility for \Strata is when all subsequent secondary search results proves  equivalent to the one obtained from initial search, in which case it  means that  secondary searches fail to add any ``confidence'' to the initial search result and the final outcome of stratification is having the same correctness guarantee as that provided by the initial search result, which is ``correctness over {\tt TS}''. But in those unfavorable case, the secondary searches might have provided ``better'' choices to pick the final formula from. A better choice of formula do not contain uninterpreted functions or  non-linear arithmetics  and are simple.  
    
   In the paper\cite{Heule2016a}, it is mentioned that there are only $50$ cases, where they found a (valid) counterexample. That means, there are $762 = (692 + 120 - 50)$ cases, where the initial search is sufficient enough to be accepted, as all the later secondary searches results are equivalent to the one obtained from the {\tt initial search}. In other words, in  most of the cases, the correctness guarantee of stratification is same as that of the initial search result. 
   
   For the unstratified instructions, we would need a \emph{semantics generator} to provide us with an initial candidate of the instruction semantics. Once we have that semantics, we could test it against hardware on the same augmented test-suite (containing $6630 = 6580 + 50$ ) that \Stoke uses and if the candidate  matches then we can claim to have the same correctness guarantee as above. 
   
   Now the missing piece, the  \emph{semantic generator}, can be  projects like \Stoke, which have manually written instruction semantics (in terms of logical formulas), or can be manually written.  We understand that this is not as efficient as \Stoke, which is fully automatic in getting these formulas, but our contribution is 1. To deliver in cases where \Stoke cannot   2. To cover  as many instruction semantics as possible. Moreover, writing the semantics manually might alleviate the need of secondary search as a means to provide ``better'' formula as we can control the complexity and choice of operations to include in the formula. Also carefully written manual formula tend to need less number of conflicting searches than the onces generated by random search engines like Stoke.
   
  

\subsection{Porting Formulas for stratified instructions to \K Rules}

For the purpose of getting  \K rules, we could have directly converted the \Strata formulas
for an instruction to \K rule assuming that the \Strata's symbolic execution over the 
stratified instruction sequence is correct.

Given that fact the \K's symbolic execution engine is more trusted as 
that has been used extensively in language-agnostic manner to perform symbolic
execution, we decided to use \K's symbolic executor. Also in order to check 
if \Strata's symbolic execution engine is correct, we did an equivalence check on 
the outputs of both the symbolic executions.   
 

\begin{enumerate}
\item Implementing the base instructions semantics in \K and testing them.
\item Symbolic execution of the stratified instruction sequences.
\item Dealing with scratch pad registers.
\item Equivalence check between \Strata formula ad the output of 2.
   
   All the checks are \emph{unsat}, expect one where the check fail to due a bug in the simplification
   rules in \Strata, which states the following lemma related to two single precision floating point numbers  {\tt A}  and {\tt B}, which is not correct for {\tt NaNs}. However this bug is fixed in 
   the latest version of \Stoke. 
   
   
   { \tt  
        \begin{tabular}[b]{l}
   \qquad add\_single(A, B) $\equiv$ A if B == 0     
      \end{tabular}
  }
   
\item {Simplification of formulas:}
  Simplification generates simple \K rule (sometimes simpler than the corresponding \Strata formula).
 Also it is much easier to write the simplification rules in
  \K.\revisit{show the example for concat(A[1:2], concate(B[2:3], X)) $\equiv$
    concate(A[1:3], X)}


\item One of the issue with \Strata formulas is they could be too complex to comprehend at times, which is mainly because 1. \Strata tried to define the semantics of an instruction using other simpler instructions, 2. The simplification rules in \Strata or the ones we define in \K are not sophisticated enough to simplify the complex formulas. An example of one such simplification opportunity is: 
     { \tt  
      \begin{tabular}[b]{l}
          ($0_{32}$ $\cdot$ \%rax[32:0]) $\oplus$ \%rax $\equiv$ \%rax[63:32] $\cdot$  $0_{32}$ 
      \end{tabular}
    }

In order to simplify those, we borrowed the hand written formula (provided they ate simpler)  from \Stoke or manually write the simpler formulas  and check equivalence with the stratified formula. If they match on all register state, we employ that in our \K semantics.       


\end{enumerate}

\subsection{Supporting un-stratified instructions \& Porting their formulas to \K Rules}

\subsubsection{Supporting un-stratified instructions}
\paragraph{Instruction support status}

\begin{figure*}[t]
\centering
\fig{figures/instruction_classification}
\caption{Instruction classification\label{fig:instr_class}}
\end{figure*}

\subsection{Porting to \K Rules}

\Strata could output the internal AST, used to model a register state formula, in different
formats. Supported backend are SmtLib and Prefix notation. We have added another backend 
to generate \K rule. We need some way to validate the backend. 

\paragraph{Validate the Backend}

The \K rules generated using the backend are matched (syntactically)  against
the ones we already obtained via symbolic execution on stratified instructions.
Other than validaing the backend, this has an added benefit that in order to get
the exact match, we need to port all the simplification rules from \K to strata
code, which in turn will later help in generating simplified \K rules for
non-stratified instructions. 

Main challenges in getting an exact match are:
\begin{itemize}

\item  \Strata rules uses \extract to extract portion of a bit-vector. The high
and low indices of \extract are obtained considering LSB at index 0, whereas \K
uses \extractMInt for the same purpose, but uses MSB at index zero.

\item  \Strata uses flags as \bool, whereas they are treated as \bv in our
semantics. We modifed strata so as to treat flag registers as 1 bit bitvectors.

\end{itemize}


