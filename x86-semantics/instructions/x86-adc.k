// Autogenerated from templates.
requires "x86-configuration.k"
requires "x86-flag-checks-syntax.k"

/*@ This file defines the semantics of following 51 base instructions.
  - adcw_r16_r16, adcl_r32_r32, adcq_r64_r64, adcb_r8_r8,
*/

module ADC-R8-R8
  imports X86-CONFIGURATION
  imports X86-FLAG-CHECKS-SYNTAX

  rule <k> 
    execinstr (adcb (R1:R8,  (R2:R8, .Typedoperands)) ) =>
      execinstr(adcb (R2, getRegisterValue(R1, RSMap), getRegisterValue(R2, RSMap), 
            zeroExtend(getFlag("CF", RSMap), 8), .Typedoperands)) 
  ...</k>
  <regstate> RSMap </regstate>

  rule <k>
    execinstr(adcb ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry:MInt, .Typedoperands )) => 
      execinstr(adcb ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry, addMInt(MIsrc1, MIsrc2), 
            addMInt(addMInt(MIsrc1, MIsrc2), MIcarry), .Typedoperands )) 
  ...</k>
  
  rule <k>
    execinstr(adcb ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry:MInt, MIsum:MInt, MIresult:MInt, .Typedoperands )) 
    => 
      updateOverflowAdd(MIsrc1, MIsrc2, MIresult) ~> 
      updateZeroFlag(MIresult) ~> 
      updateSignFlag(MIresult) ~> 
      updateAuxCarryFlag(MIsrc1, MIsrc2, MIresult) ~> 
      updateCarryFlagAdd(MIsrc1, MIsrc2, MIsum, MIcarry, MIresult) ~> 
      updateParityFlag(MIresult) ~> 
      setRegisterValue(MIresult, DestR) 
  ...</k>

endmodule

module ADC-R16-R16
  imports X86-CONFIGURATION
  imports X86-FLAG-CHECKS-SYNTAX

  rule <k> 
    execinstr (adcw (R1:R16,  (R2:R16, .Typedoperands)) ) =>
      execinstr(adcw (R2, getRegisterValue(R1, RSMap), getRegisterValue(R2, RSMap), 
            zeroExtend(getFlag("CF", RSMap), 16), .Typedoperands)) 
  ...</k>
  <regstate> RSMap </regstate>

  rule <k>
    execinstr(adcw ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry:MInt, .Typedoperands )) => 
      execinstr(adcw ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry, addMInt(MIsrc1, MIsrc2), 
            addMInt(addMInt(MIsrc1, MIsrc2), MIcarry), .Typedoperands )) 
  ...</k>
  
  rule <k>
    execinstr(adcw ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry:MInt, MIsum:MInt, MIresult:MInt, .Typedoperands )) 
    => 
      updateOverflowAdd(MIsrc1, MIsrc2, MIresult) ~> 
      updateZeroFlag(MIresult) ~> 
      updateSignFlag(MIresult) ~> 
      updateAuxCarryFlag(MIsrc1, MIsrc2, MIresult) ~> 
      updateCarryFlagAdd(MIsrc1, MIsrc2, MIsum, MIcarry, MIresult) ~> 
      updateParityFlag(MIresult) ~> 
      setRegisterValue(MIresult, DestR) 
  ...</k>

endmodule

module ADC-R32-R32
  imports X86-CONFIGURATION
  imports X86-FLAG-CHECKS-SYNTAX

  rule <k> 
    execinstr (adcl (R1:R32,  (R2:R32, .Typedoperands)) ) =>
      execinstr(adcl (R2, getRegisterValue(R1, RSMap), getRegisterValue(R2, RSMap), 
            zeroExtend(getFlag("CF", RSMap), 32), .Typedoperands)) 
  ...</k>
  <regstate> RSMap </regstate>

  rule <k> 
    execinstr(adcl ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry:MInt, .Typedoperands )) => 
      execinstr(adcl ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry, addMInt(MIsrc1, MIsrc2), 
            addMInt(addMInt(MIsrc1, MIsrc2), MIcarry), .Typedoperands )) 
  ...</k>
  
  rule <k>
    execinstr(adcl ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry:MInt, MIsum:MInt, MIresult:MInt, .Typedoperands )) 
    => 
      updateOverflowAdd(MIsrc1, MIsrc2, MIresult) ~> 
      updateZeroFlag(MIresult) ~> 
      updateSignFlag(MIresult) ~> 
      updateAuxCarryFlag(MIsrc1, MIsrc2, MIresult) ~> 
      updateCarryFlagAdd(MIsrc1, MIsrc2, MIsum, MIcarry, MIresult) ~> 
      updateParityFlag(MIresult) ~> 
      setRegisterValue(concatenateMInt(mi(32, 0), MIresult), convSubRegsToRegs(DestR)) 
  ...</k>

endmodule

module ADC-R64-R64
  imports X86-CONFIGURATION
  imports X86-FLAG-CHECKS-SYNTAX

  rule <k> 
    execinstr (adcq (R1:R64,  (R2:R64, .Typedoperands)) ) =>
      execinstr(adcq (R2, getRegisterValue(R1, RSMap), getRegisterValue(R2, RSMap), 
            zeroExtend(getFlag("CF", RSMap), 64), .Typedoperands)) 
  ...</k>
  <regstate> RSMap </regstate>

  rule <k> 
    execinstr(adcq ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry:MInt, .Typedoperands )) => 
      execinstr(adcq ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry, addMInt(MIsrc1, MIsrc2), 
            addMInt(addMInt(MIsrc1, MIsrc2), MIcarry), .Typedoperands )) 
  ...</k>
  
  rule <k>
    execinstr(adcq ( DestR, MIsrc1:MInt, MIsrc2:MInt, MIcarry:MInt, MIsum:MInt, MIresult:MInt, .Typedoperands )) 
    => 
      updateOverflowAdd(MIsrc1, MIsrc2, MIresult) ~> 
      updateZeroFlag(MIresult) ~> 
      updateSignFlag(MIresult) ~> 
      updateAuxCarryFlag(MIsrc1, MIsrc2, MIresult) ~> 
      updateCarryFlagAdd(MIsrc1, MIsrc2, MIsum, MIcarry, MIresult) ~> 
      updateParityFlag(MIresult) ~> 
      setRegisterValue(MIresult, DestR) 
  ...</k>

endmodule

module ADC-SEMANTICS
  imports ADC-R8-R8
  imports ADC-R16-R16
  imports ADC-R32-R32
  imports ADC-R64-R64
endmodule
