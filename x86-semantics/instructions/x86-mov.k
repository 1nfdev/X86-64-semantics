// Autogenerated from templates.
requires "x86-semantic-utils.k"

/*@ This file defines the semantics of following 51 base instructions.
  - movq_r64_imm64, movq_r64_r64, movb_r8_rh, movb_rh_r8,
*/

module MOV-R64-R64
  imports X86-SEMANTIC-UTILS

  // Unroll START
  rule <k> 
    execinstr ( movq , (%rax ,  (%rax , .Typedoperands)) ) => .
  ...</k>
  rule <k> 
    execinstr ( movq , (%rbx ,  (%rbx , .Typedoperands)) ) => .
  ...</k>
  rule <k> 
    execinstr ( movq , (%rcx ,  (%rcx , .Typedoperands)) ) => .
  ...</k>

  // Unroll START
  rule <k> 
    execinstr ( movq , (%rbx ,  (%rax , .Typedoperands)) ) =>
      updateReg(MI, %rax)
  ...</k>
  <rbx> MI </rbx>
  rule <k> 
    execinstr ( movq , (%rcx ,  (%rax , .Typedoperands)) ) =>
      updateReg(MI, %rax)
  ...</k>
  <rcx> MI </rcx>
  rule <k> 
    execinstr ( movq , (%rax ,  (%rbx , .Typedoperands)) ) =>
      updateReg(MI, %rbx)
  ...</k>
  <rax> MI </rax>
  rule <k> 
    execinstr ( movq , (%rcx ,  (%rbx , .Typedoperands)) ) =>
      updateReg(MI, %rbx)
  ...</k>
  <rcx> MI </rcx>
  rule <k> 
    execinstr ( movq , (%rax ,  (%rcx , .Typedoperands)) ) =>
      updateReg(MI, %rcx)
  ...</k>
  <rax> MI </rax>
  rule <k> 
    execinstr ( movq , (%rbx ,  (%rcx , .Typedoperands)) ) =>
      updateReg(MI, %rcx)
  ...</k>
  <rbx> MI </rbx>
  // Unroll END
endmodule

module MOV-R64-IMM64
  imports X86-SEMANTIC-UTILS

  // Unroll START
  rule <k> 
    execinstr ( movq , (I:Imm ,  (%rax , .Typedoperands)) ) =>
      updateReg(handleImmediate(I, 64), %rax)
  ...</k>
  rule <k> 
    execinstr ( movq , (I:Imm ,  (%rbx , .Typedoperands)) ) =>
      updateReg(handleImmediate(I, 64), %rbx)
  ...</k>
  rule <k> 
    execinstr ( movq , (I:Imm ,  (%rcx , .Typedoperands)) ) =>
      updateReg(handleImmediate(I, 64), %rcx)
  ...</k>
  // Unroll END
endmodule

module MOV-R8-RH
  imports X86-SEMANTIC-UTILS

  // Unroll START
  rule <k> 
    execinstr ( movb , (%ah ,  (%al , .Typedoperands)) ) =>
      updateReg( plugInMask(MI, extractMask(MI, 8, 8), 0), %rax)
  ...</k>
  <rax> MI </rax>
  rule <k> 
    execinstr ( movb , (%bh ,  (%bl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI, extractMask(MI, 8, 8), 0), %rbx)
  ...</k>
  <rbx> MI </rbx>
  rule <k> 
    execinstr ( movb , (%ch ,  (%cl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI, extractMask(MI, 8, 8), 0), %rcx)
  ...</k>
  <rcx> MI </rcx>
  rule <k> 
    execinstr ( movb , (%dh ,  (%dl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI, extractMask(MI, 8, 8), 0), %rdx)
  ...</k>
  <rdx> MI </rdx>
  // Unroll END

  // Unroll START
  rule <k> 
    execinstr ( movb , (%ah ,  (%bl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rbx)
  ...</k>
  <rax> MI1 </rax>
  <rbx> MI2 </rbx>
  rule <k> 
    execinstr ( movb , (%ah ,  (%cl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rcx)
  ...</k>
  <rax> MI1 </rax>
  <rcx> MI2 </rcx>
  rule <k> 
    execinstr ( movb , (%bh ,  (%al , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rax)
  ...</k>
  <rbx> MI1 </rbx>
  <rax> MI2 </rax>
  rule <k> 
    execinstr ( movb , (%bh ,  (%cl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rcx)
  ...</k>
  <rbx> MI1 </rbx>
  <rcx> MI2 </rcx>
  rule <k> 
    execinstr ( movb , (%ch ,  (%al , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rax)
  ...</k>
  <rcx> MI1 </rcx>
  <rax> MI2 </rax>
  rule <k> 
    execinstr ( movb , (%ch ,  (%bl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rbx)
  ...</k>
  <rcx> MI1 </rcx>
  <rbx> MI2 </rbx>
  rule <k> 
    execinstr ( movb , (%dh ,  (%al , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rax)
  ...</k>
  <rdx> MI1 </rdx>
  <rax> MI2 </rax>
  rule <k> 
    execinstr ( movb , (%dh ,  (%bl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rbx)
  ...</k>
  <rdx> MI1 </rdx>
  <rbx> MI2 </rbx>
  rule <k> 
    execinstr ( movb , (%dh ,  (%cl , .Typedoperands)) ) =>
      updateReg( plugInMask(MI2, extractMask(MI1, 8, 8), 0), %rcx)
  ...</k>
  <rdx> MI1 </rdx>
  <rcx> MI2 </rcx>
  // Unroll END
endmodule

module MOV-RH-R8
  imports X86-SEMANTIC-UTILS

  // Unroll START
  rule <k> 
    execinstr ( movb , (%al ,  (%ah , .Typedoperands)) ) =>
      updateReg( plugInMask(MI, extractMask(MI, 8, 0), 8), %rax)
  ...</k>
  <rax> MI </rax>
  rule <k> 
    execinstr ( movb , (%bl ,  (%bh , .Typedoperands)) ) =>
      updateReg( plugInMask(MI, extractMask(MI, 8, 0), 8), %rbx)
  ...</k>
  <rbx> MI </rbx>
  rule <k> 
    execinstr ( movb , (%cl ,  (%ch , .Typedoperands)) ) =>
      updateReg( plugInMask(MI, extractMask(MI, 8, 0), 8), %rcx)
  ...</k>
  <rcx> MI </rcx>
  rule <k> 
    execinstr ( movb , (%dl ,  (%dh , .Typedoperands)) ) =>
      updateReg( plugInMask(MI, extractMask(MI, 8, 0), 8), %rdx)
  ...</k>
  <rdx> MI </rdx>
  // Unroll END

  // Unroll START
  rule <k> 
    execinstr ( movb , (%bl ,  (%ah , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rax)
  ...</k>
  <rax> MI1 </rax>
  <rbx> MI2 </rbx>
  rule <k> 
    execinstr ( movb , (%cl ,  (%ah , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rax)
  ...</k>
  <rax> MI1 </rax>
  <rcx> MI2 </rcx>
  rule <k> 
    execinstr ( movb , (%al ,  (%bh , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rbx)
  ...</k>
  <rbx> MI1 </rbx>
  <rax> MI2 </rax>
  rule <k> 
    execinstr ( movb , (%cl ,  (%bh , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rbx)
  ...</k>
  <rbx> MI1 </rbx>
  <rcx> MI2 </rcx>
  rule <k> 
    execinstr ( movb , (%al ,  (%ch , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rcx)
  ...</k>
  <rcx> MI1 </rcx>
  <rax> MI2 </rax>
  rule <k> 
    execinstr ( movb , (%bl ,  (%ch , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rcx)
  ...</k>
  <rcx> MI1 </rcx>
  <rbx> MI2 </rbx>
  rule <k> 
    execinstr ( movb , (%al ,  (%dh , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rdx)
  ...</k>
  <rdx> MI1 </rdx>
  <rax> MI2 </rax>
  rule <k> 
    execinstr ( movb , (%bl ,  (%dh , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rdx)
  ...</k>
  <rdx> MI1 </rdx>
  <rbx> MI2 </rbx>
  rule <k> 
    execinstr ( movb , (%cl ,  (%dh , .Typedoperands)) ) =>
      updateReg( plugInMask(MI1, extractMask(MI2, 8, 0), 8), %rdx)
  ...</k>
  <rdx> MI1 </rdx>
  <rcx> MI2 </rcx>
  // Unroll END
endmodule

module MOV-SEMANTICS
  imports MOV-R64-R64
  imports MOV-R64-IMM64
  imports MOV-R8-RH
  imports MOV-RH-R8
endmodule
