// Autogenerated using stratification.
requires "x86-configuration.k"

module TESTB-RH-R8
  imports X86-CONFIGURATION

  rule <k>
    execinstr (testb R1:R8, R2:Rh,  .Typedoperands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
 "CF" |-> (mi(1, 0) )

 "SF" |-> (xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 33), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 33), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 33), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 33)))) )

 "AF" |-> (undef)

 "PF" |-> ((#ifMInt ( (  ( countOnes(xorMInt(extractMInt(getParentValue(R2, RSMap), 48, 56), xorMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), orMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), extractMInt(getParentValue(R2, RSMap), 48, 56)))), 0)  &Int  1 )  ==K  0 )  ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)  )

 "OF" |-> (mi(1, 0) )

 "ZF" |-> ((#ifMInt (eqMInt(xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 64), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 64), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 56, 64))), 32, 64), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 56))), 32, 64)))), mi(32, 0)) ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)    )


)

    </regstate>
endmodule

module TESTB-RH-R8-SEMANTICS
  imports TESTB-RH-R8
endmodule
/*
TargetInstr:
testb %bl, %ah
RWSet:
maybe read:{ %ah %bl }
must read:{ %ah %bl }
maybe write:{ %cf %pf %zf %sf %of }
must write:{ %cf %pf %zf %sf %of }
maybe undef:{ %af }
must undef:{ %af }
required flags:{ }

Circuit:
circuit:xorl %edx, %edx  #  1     0    2      OPC=xorl_r32_r32
circuit:callq .clear_cf  #  2     0x2  5      OPC=callq_label
circuit:setg %bh         #  3     0x7  3      OPC=setg_rh
circuit:adcw %bx, %dx    #  4     0xa  3      OPC=adcw_r16_r16
circuit:testb %ah, %dl   #  5     0xd  2      OPC=testb_r8_rh
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

testb %bl, %ah

  maybe read:      { %ah %bl }
  must read:       { %ah %bl }
  maybe write:     { %cf %pf %zf %sf %of }
  must write:      { %cf %pf %zf %sf %of }
  maybe undef:     { %af }
  must undef:      { %af }
  required flags:  { }

Circuits:

%cf    : false
%pf    : !(((%rax[8:8] | %rbx[0:0]) ⊕ %rbx[0:0] ⊕ %rax[8:8]) = 0x1₁ ⊕ ((%rax[9:9] | %rbx[1:1]) ⊕ %rbx[1:1] ⊕ %rax[9:9]) = 0x1₁ ⊕ ((%rax[10:10] | %rbx[2:2]) ⊕ %rbx[2:2] ⊕ %rax[10:10]) = 0x1₁ ⊕ ((%rax[11:11] | %rbx[3:3]) ⊕ %rbx[3:3] ⊕ %rax[11:11]) = 0x1₁ ⊕ ((%rax[12:12] | %rbx[4:4]) ⊕ %rbx[4:4] ⊕ %rax[12:12]) = 0x1₁ ⊕ ((%rax[13:13] | %rbx[5:5]) ⊕ %rbx[5:5] ⊕ %rax[13:13]) = 0x1₁ ⊕ ((%rax[14:14] | %rbx[6:6]) ⊕ %rbx[6:6] ⊕ %rax[14:14]) = 0x1₁ ⊕ ((%rax[15:15] | %rbx[7:7]) ⊕ %rbx[7:7] ⊕ %rax[15:15]) = 0x1₁)
%zf    : ((sign-extend-64(%rax[15:8])[31:0] | sign-extend-64(%rbx[7:0])[31:0]) ⊕ sign-extend-64(%rbx[7:0])[31:0] ⊕ sign-extend-64(%rax[15:8])[31:0]) = 0x0₃₂
%sf    : ((sign-extend-64(%rax[15:8])[31:31] | sign-extend-64(%rbx[7:0])[31:31]) ⊕ sign-extend-64(%rbx[7:0])[31:31] ⊕ sign-extend-64(%rax[15:8])[31:31]) = 0x1₁
%of    : false

sigfpe  : sigfpe
sigbus  : sigbus
sigsegv : sigsegv

*/