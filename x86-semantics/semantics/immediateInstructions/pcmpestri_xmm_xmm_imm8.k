// Autogenerated using stratification.
requires "x86-configuration.k"

module PCMPESTRI-XMM-XMM-IMM8
  imports X86-CONFIGURATION

  // Find Limit Index
  rule <k>
    execinstr (pcmpestri Imm8:Imm, Xmm2:Xmm, Xmm1:Xmm,  .Operands) => 
      execinstr (pcmpestri 
          handleImmediateWithSignExtend(Imm8, 8, 8), 
          Xmm2, 
          Xmm1, 
          getRegisterValue(Xmm2, RSMap), 
          getRegisterValue(Xmm1, RSMap),
          findLimitIndexE(getRegisterValue(Xmm2, RSMap), getRegisterValue(%rdx, RSMap), handleImmediateWithSignExtend(Imm8, 8, 8)),   
          findLimitIndexE(getRegisterValue(Xmm1, RSMap), getRegisterValue(%rax, RSMap), handleImmediateWithSignExtend(Imm8, 8, 8)),   
          .Operands) 
  ...</k>
  <regstate> RSMap </regstate>

   // Find data size and interpretation
  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, .Operands) => 
      execinstr (pcmpestri Imm8, Xmm2, Xmm1, Value2, Value1, Limit2, Limit1,
          #ifMInt eqMInt(extractMInt(Imm8, 7, 8), mi(1, 1)) #then mi(8,8) #else mi(8, 16) #fi, 
          extractMInt(Imm8, 6, 7),  .Operands)
  ...</k>


  // Aggregation operation
  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, .Operands) => 
      execinstr (pcmpestri Imm8, Xmm2, Xmm1, Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, equalAnyImpl(Value2, Value1, Limit2, Limit1, uvalueMInt(NumElems), SignedOrUnsigned), .Operands)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 4, 6), mi(2, 0))
    
  /*
  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, .Operands) => 
      execinstr (pcmpestri Imm8, Xmm2, Xmm1, Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, rangeImpl(Value2, Value1, Limit2, Limit1, NumElems, SignedOrUnsigned), .Operands)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 4, 6), mi(2, 1))

  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, .Operands) => 
      execinstr (pcmpestri Imm8, Xmm2, Xmm1, Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, equalEachImpl(Value2, Value1, Limit2, Limit1, NumElems, SignedOrUnsigned), .Operands)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 4, 6), mi(2, 2))

  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, .Operands) => 
      execinstr (pcmpestri Imm8, Xmm2, Xmm1, Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, equalOrderedImpl(Value2, Value1, Limit2, Limit1, NumElems, SignedOrUnsigned), .Operands)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 4, 6), mi(2, 3) )   

  // Polarity
  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, IntRes1:MInt, .Operands) => 
      execinstr (pcmpestri Imm8, Xmm2, Xmm1, Value2, Value1, Limit2, Limit1,  NumElems, SignedOrUnsigned, IntRes1, polarityImpl(IntRes1, Imm8), .Operands)
  ...</k>
  */
      
  // Output Selection

  // If no bit is set, 16 or 8 is returned.
  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, IntRes1:MInt, IntRes2:MInt, .Operands) => 
      setRegisterValue(mi(64, uvalueMInt(NumElems)), %rcx)
  ...</k>
    requires  eqMInt(IntRes2, mi(bitwidthMInt(IntRes2), 0))

  // ELse
  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, IntRes1:MInt, IntRes2:MInt, .Operands) => 
      setRegisterValue(mi(64, scanForward(IntRes2, uvalueMInt(NumElems) -Int 1, uvalueMInt(NumElems))), %rcx)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 1, 2), mi(2, 0)) 
      andBool  notBool eqMInt(IntRes2, mi(bitwidthMInt(IntRes2), 0))

  rule <k>
    execinstr (pcmpestri Imm8:MInt, Xmm2:Xmm, Xmm1:Xmm, Value2:MInt, Value1:MInt, Limit2:MInt, Limit1:MInt, NumElems:MInt, SignedOrUnsigned:MInt, IntRes1:MInt, IntRes2:MInt, .Operands) => 
      setRegisterValue(mi(64, scanReverse(IntRes2, 0, uvalueMInt(NumElems))), %rcx)
  ...</k>
    requires eqMInt(extractMInt(Imm8, 1, 2), mi(2, 1) )
      andBool  notBool eqMInt(IntRes2, mi(bitwidthMInt(IntRes2), 0))
      
endmodule

module ADCQ-R64-IMM8-SEMANTICS
  imports ADCQ-R64-IMM8
endmodule
