// Autogenerated using stratification.
requires "x86-configuration.k"

module SHLDQ-R64-R64
  imports X86-CONFIGURATION

  rule <k>
    execinstr (shldq %cl, R2:R64, R1:R64,  .Operands) =>  
      execinstr (shldq R1, getRegisterValue(R1, RSMap), getRegisterValue(R2, RSMap), 
          shiftCountMask(getRegisterValue(%cl, RSMap), 64),  .Operands)
  ...</k>
    <regstate> RSMap </regstate>

  rule <k>
    execinstr (shldq R, MIsrc1:MInt, MIsrc2:MInt, MIsrc3:MInt, .Operands) => .
  ...</k> 
    requires eqMInt(MIsrc3, mi(bitwidthMInt(MIsrc3), 0))

  rule <k>
    execinstr (shldq R, MIsrc1:MInt, MIsrc2:MInt, MIsrc3:MInt, .Operands) => .
  ...</k> 
   <regstate>
  RSMap:Map => updateMap(RSMap,
  convToRegKeys(R2) |-> (undefMInt)
    "ZF" |-> (undefMInt)
    "SF" |-> (undefMInt)
    "CF" |-> (undefMInt)
    "OF" |-> (undefMInt)
    "PF" |-> (undefMInt)
    "AF" |-> (undefMInt)
  )
   </regstate>
      requires ugtMInt(MIsrc3, mi(bitwidthMInt(MIsrc3), bitwidthMInt(MIsrc1)))


  rule <k>
    execinstr (shldq R, MIsrc1:MInt, MIsrc2:MInt, MIsrc3:MInt, .Operands) => 
      execinstr (shldq R, MIsrc1:MInt, MIsrc2:MInt, MIsrc3:MInt, 
          orMInt( shiftLeftMInt(MIsrc1, uvalueMInt(MIsrc3)),
          lshrMInt(MIsrc2, bitwidthMInt(MIsrc1) -Int uvalueMInt(MIsrc3))),
          .Operands) 
  ...</k> 
      requires uleMInt(MIsrc3, mi(bitwidthMInt(MIsrc3), bitwidthMInt(MIsrc1)))

  rule <k>
    execinstr (shldq R, MIsrc1:MInt, MIsrc2:MInt, MIsrc3:MInt, MIresult:MInt, .Operands) => 
      setFlag(extractMInt(MIsrc1, uvalueMInt(MIsrc3) -Int 1, uvalueMInt(MIsrc3)), "CF") ~> 
      updateSignFlag(MIresult) ~> 
      updateZeroFlag(MIresult) ~> 
      updateParityFlag(MIresult) ~> 

      updateOverflowFlag(
          xorMInt(extractMInt(MIsrc1, 0, 1), extractMInt(MIresult, 0, 1))
      ) ~>
      setFlag(undefMInt, "AF") ~> 
      setRegisterValue(MIresult, R)
  ...</k> 
      requires eqMInt(MIsrc3, mi(bitwidthMInt(MIsrc3), 1))
  
  rule <k>
    execinstr (shldq R, MIsrc1:MInt, MIsrc2:MInt, MIsrc3:MInt, MIresult:MInt, .Operands) => 
      setFlag(extractMInt(MIsrc1, uvalueMInt(MIsrc3) -Int 1, uvalueMInt(MIsrc3)), "CF") ~> 
      updateSignFlag(MIresult) ~> 
      updateZeroFlag(MIresult) ~> 
      updateParityFlag(MIresult) ~> 

      updateOverflowAdd(mi(1, 0)) ~>
      setFlag(undefMInt, "AF") ~> 
      setRegisterValue(MIresult, R)
  ...</k> 
      requires uleMInt(MIsrc3, mi(bitwidthMInt(MIsrc3), bitwidthMInt(MIsrc1)))
        andBool (notBool eqMInt(MIsrc3, mi(bitwidthMInt(MIsrc3), 1)))
endmodule
