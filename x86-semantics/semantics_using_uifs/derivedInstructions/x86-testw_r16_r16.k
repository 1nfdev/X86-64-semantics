// Autogenerated using stratification.
requires "x86-configuration.k"

module TESTW-R16-R16
  imports X86-CONFIGURATION

  rule <k>
    execinstr (testw R1:R16, R2:R16,  .Operands) => .
  ...</k>
    <regstate>
RSMap:Map => updateMap(RSMap,
 "CF" |-> (mi(1, 0) )

 "SF" |-> (xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 64))), 32, 33), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 64))), 32, 33), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 64))), 32, 33), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 64))), 32, 33)))) )

 "AF" |-> (undef)

 "PF" |-> ((#ifMInt ( (  ( countOnes(xorMInt(extractMInt(getParentValue(R1, RSMap), 56, 64), xorMInt(extractMInt(getParentValue(R2, RSMap), 56, 64), orMInt(extractMInt(getParentValue(R2, RSMap), 56, 64), extractMInt(getParentValue(R1, RSMap), 56, 64)))), 0)  &Int  1 )  ==K  0 )  ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)  )

 "OF" |-> (mi(1, 0) )

 "ZF" |-> ((#ifMInt (eqMInt(xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 64))), 32, 64), xorMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 64))), 32, 64), orMInt(extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R2, RSMap), 48, 64))), 32, 64), extractMInt(mi(64, svalueMInt(extractMInt(getParentValue(R1, RSMap), 48, 64))), 32, 64)))), mi(32, 0)) ) #then ( mi(1, 1) ) #else ( mi(1, 0) ) #fi)    )


)

    </regstate>
endmodule

module TESTW-R16-R16-SEMANTICS
  imports TESTW-R16-R16
endmodule
/*
TargetInstr:
testw %cx, %bx
RWSet:
maybe read:{ %cx %bx }
must read:{ %cx %bx }
maybe write:{ %cf %pf %zf %sf %of }
must write:{ %cf %pf %zf %sf %of }
maybe undef:{ %af }
must undef:{ %af }
required flags:{ }

Circuit:
circuit:movswq %bx, %r10   #  1     0    4      OPC=movswq_r64_r16
circuit:movswl %cx, %edi   #  2     0x4  3      OPC=movswl_r32_r16
circuit:xchgl %edi, %r10d  #  3     0x7  3      OPC=xchgl_r32_r32
circuit:andl %r10d, %edi   #  4     0xa  3      OPC=andl_r32_r32
BVF:
WARNING: No live out values provided, assuming { }
WARNING: No def in values provided; assuming { %mxcsr::rc[0] }
Target

testw %cx, %bx

  maybe read:      { %cx %bx }
  must read:       { %cx %bx }
  maybe write:     { %cf %pf %zf %sf %of }
  must write:      { %cf %pf %zf %sf %of }
  maybe undef:     { %af }
  must undef:      { %af }
  required flags:  { }

Circuits:

%cf    : FALSE
%pf    : (not (xor (xor (xor (xor (xor (xor (xor (== (^ (^ (| <%rcx|64>[0:0] <%rbx|64>[0:0]) <%rbx|64>[0:0]) <%rcx|64>[0:0]) <0x1|1>) (== (^ (^ (| <%rcx|64>[1:1] <%rbx|64>[1:1]) <%rbx|64>[1:1]) <%rcx|64>[1:1]) <0x1|1>)) (== (^ (^ (| <%rcx|64>[2:2] <%rbx|64>[2:2]) <%rbx|64>[2:2]) <%rcx|64>[2:2]) <0x1|1>)) (== (^ (^ (| <%rcx|64>[3:3] <%rbx|64>[3:3]) <%rbx|64>[3:3]) <%rcx|64>[3:3]) <0x1|1>)) (== (^ (^ (| <%rcx|64>[4:4] <%rbx|64>[4:4]) <%rbx|64>[4:4]) <%rcx|64>[4:4]) <0x1|1>)) (== (^ (^ (| <%rcx|64>[5:5] <%rbx|64>[5:5]) <%rbx|64>[5:5]) <%rcx|64>[5:5]) <0x1|1>)) (== (^ (^ (| <%rcx|64>[6:6] <%rbx|64>[6:6]) <%rbx|64>[6:6]) <%rcx|64>[6:6]) <0x1|1>)) (== (^ (^ (| <%rcx|64>[7:7] <%rbx|64>[7:7]) <%rbx|64>[7:7]) <%rcx|64>[7:7]) <0x1|1>)))
%zf    : (== (^ (^ (| (sign-extend-64 <%rcx|64>[15:0])[31:0] (sign-extend-64 <%rbx|64>[15:0])[31:0]) (sign-extend-64 <%rbx|64>[15:0])[31:0]) (sign-extend-64 <%rcx|64>[15:0])[31:0]) <0x0|32>)
%sf    : (== (^ (^ (| (sign-extend-64 <%rcx|64>[15:0])[31:31] (sign-extend-64 <%rbx|64>[15:0])[31:31]) (sign-extend-64 <%rbx|64>[15:0])[31:31]) (sign-extend-64 <%rcx|64>[15:0])[31:31]) <0x1|1>)
%of    : FALSE

sigfpe  : <sigfpe>
sigbus  : <sigbus>
sigsegv : <sigsegv>

*/