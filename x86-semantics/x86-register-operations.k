requires "x86-syntax.k"
requires "x86-configuration.k"
requires "x86-general-utils.k"

module X86-REGISTER-OPERATIONS
  imports X86-SYNTAX
  imports X86-CONFIGURATION
  imports X86-GENERAL-UTILS

  /*@
    if the top computational task is to update a register, say Rd with a computed
    value I, the previous value of Rd, denoted by the wildcard _, is replaced by
    I, as shown below.
  */
  syntax KItem ::= updateReg(K, Register) [strict(1)]

  syntax Typeoperand ::= MInt

  // Autogenerated 
  rule <k> %rax => MI ...</k> <rax> MI </rax>
  rule <k> %rbx => MI ...</k> <rbx> MI </rbx>
  rule <k> %rcx => MI ...</k> <rcx> MI </rcx>
  rule <k> %rdx => MI ...</k> <rdx> MI </rdx>
  rule <k> %rsi => MI ...</k> <rsi> MI </rsi>
  rule <k> %rdi => MI ...</k> <rdi> MI </rdi>
  rule <k> %rsp => MI ...</k> <rsp> MI </rsp>
  rule <k> %rbp => MI ...</k> <rbp> MI </rbp>
  rule <k> %r8 => MI ...</k> <r8> MI </r8>
  rule <k> %r9 => MI ...</k> <r9> MI </r9>
  rule <k> %r10 => MI ...</k> <r10> MI </r10>
  rule <k> %r11 => MI ...</k> <r11> MI </r11>
  rule <k> %r12 => MI ...</k> <r12> MI </r12>
  rule <k> %r13 => MI ...</k> <r13> MI </r13>
  rule <k> %r14 => MI ...</k> <r14> MI </r14>
  rule <k> %r15 => MI ...</k> <r15> MI </r15>


  rule <k> updateReg(MI:MInt, %rax) => . ...</k> <rax> _ => MI </rax>
  rule <k> updateReg(MI:MInt, %rbx) => . ...</k> <rbx> _ => MI </rbx>
  rule <k> updateReg(MI:MInt, %rcx) => . ...</k> <rcx> _ => MI </rcx>
  rule <k> updateReg(MI:MInt, %rdx) => . ...</k> <rdx> _ => MI </rdx>
  rule <k> updateReg(MI:MInt, %rsi) => . ...</k> <rsi> _ => MI </rsi>
  rule <k> updateReg(MI:MInt, %rdi) => . ...</k> <rdi> _ => MI </rdi>
  rule <k> updateReg(MI:MInt, %rsp) => . ...</k> <rsp> _ => MI </rsp>
  rule <k> updateReg(MI:MInt, %rbp) => . ...</k> <rbp> _ => MI </rbp>
  rule <k> updateReg(MI:MInt, %r8) => . ...</k> <r8> _ => MI </r8>
  rule <k> updateReg(MI:MInt, %r9) => . ...</k> <r9> _ => MI </r9>
  rule <k> updateReg(MI:MInt, %r10) => . ...</k> <r10> _ => MI </r10>
  rule <k> updateReg(MI:MInt, %r11) => . ...</k> <r11> _ => MI </r11>
  rule <k> updateReg(MI:MInt, %r12) => . ...</k> <r12> _ => MI </r12>
  rule <k> updateReg(MI:MInt, %r13) => . ...</k> <r13> _ => MI </r13>
  rule <k> updateReg(MI:MInt, %r14) => . ...</k> <r14> _ => MI </r14>
  rule <k> updateReg(MI:MInt, %r15) => . ...</k> <r15> _ => MI </r15>


  /*@
    handleImmediate(Imm, W): Compute a MInt corresponding
    to the Imm value of width W.
  */
  syntax MInt ::=  handleImmediate(Imm, Int) [function]
  
  // Imm could be an Int
  rule handleImmediate($ I:Int, W:Int) => mi(W,I)
  // Or a HexConstant
  syntax String ::= HexConstant2String ( HexConstant )    [function, hook(STRING.token2string)]
  rule handleImmediate($0x H:HexConstant, W:Int) => 
    mi(W, String2Base(HexConstant2String(H), 16)) 

endmodule
